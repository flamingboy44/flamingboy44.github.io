<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>forest simulator 3d</title>
		<style>
			@font-face {
				font-family: "Rock Salt";
				src: url("./RockSalt-Regular.ttf");
			}
			@font-face {
				font-family: "Canterbury";
				src: url("./Canterbury.ttf");
			}
			:root {
				--block-size: 50px;
			}
			* {
				box-sizing: border-box;
				font-family: "Franklin Gothic Medium", Arial, Helvetica, sans-serif;
			}
			html,body {
				width: 100%;
				height: 100%;
			}
			body {
				margin: 0;
				overflow: hidden;
				overscroll-behavior: none;
			}
			#canvas-wrapper,#game,#thing {
				width: 100%;
				height: 100%;
				outline: none;
			}
			#game {
				user-select: none;
			}
			#canvas {
				position: absolute;
				width: 100%;
				height: 100%;
			}
			#canvas2 {
				position: absolute;
				width: 100%;
				height: 100%;
				mix-blend-mode: lighten;
				transform: translate(calc(var(--block-size) * 0.5), 0px);
			}
			#shop-button {
				position: absolute;
				top: 10px;
				right: 10px;
				color: black;
				background-color: white;
				border: 5px solid black;
				border-radius: 5px;
				padding: 10px;
				font-size: 20px;
			}
			#shop {
				display: none;
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				border-radius: 10px;
				border: 5px solid black;
				padding: 5px;
				width: 80%;
				height: calc(100% - 100px);
				overflow: auto;
				background-image: repeating-linear-gradient(
					90deg,
					#FFFFFF,
					#FFFFFF 20px,
					#FFEEEE 20px,
					#FFEEEE 40px
				);
				user-select: none;
			}
			.gui-text {
				margin: 0;
				color: #DDDDAA;
				font-size: max(5px, 2.5vw);
				text-shadow: -1px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, 1px -1px 0px #000000;
			}
			#stats {
				position: absolute;
				left: 10px;
				top: 2px;
			}
			h1,h2,h3,h4 {
				margin: 0;
			}
			.bar {
				width: 40%;
				height: 40px;
				background-color: black;
				outline: 3px ridge #334455;
				border-radius: 3px;
				transform: skew(-45deg) translate(20px, 0px);
			}
			#health {
				position: absolute;
				bottom: 3px;
				left: 3px;
			}
			#health-inner {
				width: 100%;
				height: 40px;
				background-color: rgb(0, 255, 0);
			}
			#oxygen {
				position: absolute;
				bottom: 50px;
				left: 0px;
			}
			#oxygen-inner {
				width: 100%;
				height: 40px;
				background-color: rgb(0, 0, 255);
			}
			#joystick {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: center;
				bottom: 100px;
				right: 100px;
				width: 200px;
				height: 200px;
				background-color: gray;
				border-radius: 50%;
				opacity: 0.8;
				display: none;
			}
			#circle-thing {
				width: 50px;
				height: 50px;
				background-color: lightgray;
				border-radius: 50%;
				transform: translate(0px, 0px);
			}
			#shop-coins {
				float: left;
			}
			#shop-gems {
				float: right;
			}
			#notification {
				position: absolute;
				font-size: 30px;
				color: yellow;
				bottom: 10%;
				left: 0px;
				width: 100%;
				text-align: center;
				text-shadow: 0px 0px 3px black;
				pointer-events: none;
			}
			#obelisk-shop {
				display: none;
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				border-radius: 10px;
				border: 5px solid black;
				padding: 5px;
				width: 80%;
				height: calc(100% - 100px);
				overflow: auto;
				background-image: repeating-linear-gradient(
					90deg,
					#EEEEFF,
					#EEEEFF 20px,
					#DDDDEE 20px,
					#DDDDEE 40px
				);
				user-select: none;
			}
			#obelisk-shop-button {
				position: absolute;
				top: 70px;
				right: 10px;
				color: black;
				background-color: white;
				border: 5px solid black;
				border-radius: 5px;
				padding: 10px;
				font-size: 20px;
			}
			#menu {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: space-around;
				flex-direction: column;
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
				background-image: url("https://www.adorama.com/alc/wp-content/uploads/2018/11/landscape-photography-tips-yosemite-valley-feature.jpg");
				background-size: 100% 100%;
				padding: 50px;
			}
			#menu-title {
				font-size: 60px;
			}
			.menu-text {
				color: white;
				text-shadow: 3px 3px 5px black;
			}
			#menu-button {
				font-size: 30px;
				padding: 0.5em 5em;
				background-color: white;
				border: 3px solid black;
				border-radius: 10px;
				box-shadow: 3px 3px 10px black;
			}
			#seed-wrapper label {
				font-size: 30px;
				color: white;
			}
			#seed-wrapper div {
				display: inline-block;
			}
			#seed-wrapper p {
				color: white;
				font-size: 15px;
				margin: 0px;
			}
			#seed {
				font-size: 30px;
				width: 20vw;
				font-family: "Consolas", "Courier New", monospace;
			}
			#seed-as-number-checkbox {
				transform: scale(2);
			}
			#menu-button:hover {
				box-shadow: inset 3px 3px 10px black;
			}
			button {
				background-color: white;
				border: 2px solid black;
				border-radius: 4px;
				margin: 1px;
			}
			button:hover,#shop-button:hover,#obelisk-shop-button:hover {
				background-color: #DDDDDD;
				cursor: pointer;
			}
			td div {
				width: 100%;
				display: flex;
				flex-direction: row;
			}
			td div button {
				border: 2px outset #D0D0D0;
				border-radius: 0px;
				background-color: #DDDDDD;
				margin: 0px;
				flex-grow: 1;
			}
			td div button:hover {
				border: 2px inset #D0D0D0;
				background-color: #CCCCCC;
				transform: none;
			}
			/* button:focus {
				box-shadow: inset 0px 0px 5px black;
			} */
			#arrow-keys {
				position: absolute;
				bottom: 10px;
				right: 10px;
				width: 300px;
				height: 100px;
				display: none;
				flex-direction: column;
			}
			.arrow-key {
				color: white;
				background-color: rgba(100, 100, 100, 0.8);
				border-radius: 5px;
				width: 100px;
				height: 50px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 30px;
			}
			.arrow-key:hover {
				background-color: rgba(80, 80, 80, 0.8);
			}
			.arrow-key:active {
				background-color: rgba(50, 50, 50, 0.9);
			}
			#arrow-keys-top {
				width: 300px;
				height: 50px;
				display: flex;
				flex-direction: row;
				justify-content: center;
			}
			#arrow-keys-bottom {
				width: 300px;
				height: 50px;
				display: flex;
				flex-direction: row;
			}
			#cursor {
				position: absolute;
				width: 30px;
				height: 30px;
				left: 0px;
				top: 0px;
				pointer-events: none;
				display: block;
			}
			#cursor-horizontal,#cursor-vertical,#cursor-center {
				position: absolute;
				background-color: black;
			}
			#cursor-horizontal {
				width: 30px;
				height: 3px;
				left: 0px;
				top: 13.5px;
			}
			#cursor-vertical {
				width: 3px;
				height: 30px;
				left: 13.5px;
				top: 0px;
			}
			#cursor-center {
				width: 3px;
				height: 3px;
				left: 13.5px;
				top: 13.5px;
				background-color: white;
			}
			#score {
				position: absolute;
				top: 20px;
				left: 50%;
				transform: translate(-50%, -50%);
			}
			#death-screen {
				position: absolute;
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
				background-image: linear-gradient(to bottom, rgba(255, 0, 0, 1), rgba(0, 0, 0, 0));
				display: none;
				font-family: 'Times New Roman', Times, serif;
				font-weight: bold;
				font-size: 75px;
				color: #550000;
				align-items: center;
				justify-content: center;
			}
			.emoji {
				width: 1em;
				height: 1em;
				display: inline-block;
				background-size: contain;
				outline: 2px solid black;
			}
			#totem-emoji {
				background-image: url("https://m.media-amazon.com/images/I/41yYu0ji5GL._AC_UF894,1000_QL80_.jpg");
			}
			table,tr,td,th {
				border: 1px solid black;
				border-collapse: separate;
				border-spacing: 2px;
			}
			td {
				height: 1em;
			}
			.shop-title {
				width: 100%;
				text-align: center;
			}
			#shop-coins,#shop-gems {
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			.shop-item {
				text-align: center;
				display: flex;
				flex-direction: column;
				align-items: center;
			}
			#shop-sections {
				width: 100%;
				display: flex;
				flex-direction: row;
				justify-content: space-around;
			}
			h2 {
				font-size: 25px;
				font-weight: bold;
			}
			.small {
				font-size: 23px;
				font-weight: bold;
			}
			#hacker-console {
				position: absolute;
				bottom: 100px;
				left: 0px;
				right: 20px;
				margin: 1px;
				display: none;
			}
			#hacker-console-text {
				background-color: black;
				color: #00FF00;
				font-family: Consolas, "Courier New", monospace;
				width: 100%;
				outline: none;
				border: none;
			}
			#hacker-console-text:focus {
				outline: 1px solid #00FF00;
			}
			#seed-label-input {
				font-family: Consolas, "Courier New", monospace;
				width: 11ch;
			}
			#scroll-container {
				position: absolute;
				top: 0px;
				left: 0px;
				width: 100%;
				height: 100%;
				display: none;
				align-items: center;
				justify-content: center;
				pointer-events: none;
			}
			.scroll {
				background-image: url("./scroll.png");
				background-size: 100% 100%;
				height: 100%;
				padding: 8% 4% 8% 4%;
				width: calc(100vh * (859 / 1100));
				pointer-events: all;
			}
			.scroll div {
				font-family: Canterbury, "Rock Salt", serif, "Comic Sans MS", cursive;
				color: rgba(10, 10, 10, 0.7);
				font-size: 3vh;
				width: 100%;
				height: 100%;
				text-decoration: underline;
				text-decoration-thickness: 1px;
				overflow-wrap: break-word;
				text-shadow: 0px 0px 7px rgba(0, 0, 0, 0.15);
				overflow-y: auto;
			}
			.scroll div::first-letter {
				font-size: 2em;
			}
		</style>
	</head>
	<body>
		<div id="thing" tabindex="0" onkeydown="globalKeyDownFunction(event);" onkeyup="keysDown[event.key] = false;">
			<div id="game" tabindex="0" onmouseup="joystick.mouseUp(event);" ontouchend="joystick.mouseUp(event);" onmousemove="joystick.mouseMove(event);" ontouchmove="joystick.mouseMove(event);" oncontextmenu="return false;">
				<div id="canvas-wrapper" tabindex="0" onkeydown="keyDownFunction(event);" onclick="hideScroll();">
					<canvas id="canvas"></canvas>
					<canvas id="canvas2"></canvas>
				</div>
				<div id="scroll-container">
					<div class="scroll">
						<div>
							
						</div>
					</div>
					<!-- <div class="scroll">
						<div>
							Verily, sentries be great dark towering figures and doth spawn from sentry barracks and ne'er die unless they doth touch a mimic. Sentries hath the ability to step up everything under 3 blocks and canst climb ladders as well.
						</div>
					</div>
					<div class="scroll">
						<div>
							Possessed dolls doth spawn as unpossessed and doth sit down. When the clock doth strike 12 am, they doth wake up and walk towards thee. An thou art caught by a possessed doll, thou art possessed for 15 ticks. Whilst thou art possessed, thou canst not control thy movements, for the possessed doll doth control thy movement. Possessed dolls doth become unpossessed at morn, and they doth spawn about every 3000 blocks.
						</div>
					</div> -->
				</div>
				<div id="death-screen">
					YOU DIED
				</div>
				<div id="stats" class="gui-text"></div>
				<div id="score" class="gui-text" title="clicking this doesnt do anything"></div>
				<button id="shop-button" onclick="shopButton();">SHOP</button>
				<button id="obelisk-shop-button" onclick="obeliskShopButton();">OBELISK</button>
				<div id="oxygen" class="bar">
					<div id="oxygen-inner"></div>
				</div>
				<div id="health" class="bar">
					<div id="health-inner"></div>
				</div>
				<div id="joystick" onmousedown="joystick.mouseDown(event);" ontouchstart="joystick.mouseDown(event);"><div id="circle-thing"></div></div>
				<div id="arrow-keys">
					<div id="arrow-keys-top">
						<div class="arrow-key arrow-up">^</div>
					</div><br>
					<div id="arrow-keys-bottom">
						<div class="arrow-key arrow-left">&lt;</div>
						<div class="arrow-key arrow-down">v</div>
						<div class="arrow-key arrow-right">&gt;</div>
					</div>
				</div>
			</div>
			<div id="shop">
				<div class="shop-title">
					<h1>üôõ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SHOP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüôô</h1>
				</div>
				<div id="saves">
					<button id="save-slot-selector" onclick="saveSlotSelectorButton();">slot 0 (click to change)</button><br>
					<button onclick="saveSlot(saveSlotNumber);">save</button>
					<button onclick="loadSlot(saveSlotNumber);">load</button>
					<button onclick="exportSave();">export save</button>
					<button onclick="importSave();">import save</button>
					<label id="seed-label">seed: <input type="text" readonly id="seed-label-input"></input></label>
					<button onclick="blockSize = clamp(blockSize * 1.5, 0.86707649579, 168.75);cameraSnapPending = true;">zoom in</button>
					<button onclick="blockSize = clamp(blockSize / 1.5, 0.86707649579, 168.75);cameraSnapPending = true;">zoom out</button><br>
					<input type="checkbox" id="joystick-checkbox"><label for="joystick-checkbox">joystick</label>
					<input type="checkbox" id="animations-checkbox"><label for="animations-checkbox">animations</label>
					<input type="checkbox" id="grim-reaper-checkbox" checked><label for="grim-reaper-checkbox">show grim reaper</label>
				</div>
				<hr>
				<div id="shop-sections">
					<div id="shop-coins">
						<div class="shop-item">
							<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî B<span class="small">OOT</span>S ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
							<table>
								<th>boots</th><th>price</th><th></th>
								<tr>
									<td>hondas</td>
									<td>free</td>
									<td><div><button onclick="equipBoots('hondas');">equip</button></div></td>
								</tr>
								<tr>
									<td>tennis rackets</td>
									<td>30 coins</td>
									<td><div><button onclick="purchaseBoots('tennis rackets');">purchase</button><button onclick="equipBoots('tennis rackets');">equip</button></div></td>
								</tr>
								<tr>
									<td>running shoes</td>
									<td>60 coins</td>
									<td><div><button onclick="purchaseBoots('running shoes');">purchase</button><button onclick="equipBoots('running shoes');">equip</button></div></td>
								</tr>
								<tr>
									<td>spring boots</td>
									<td>90 coins</td>
									<td><div><button onclick="purchaseBoots('spring boots');">purchase</button><button onclick="equipBoots('spring boots');">equip</button></div></td>
								</tr>
								<tr>
									<td>spike boots</td>
									<td>100 coins</td>
									<td><div><button onclick="purchaseBoots('spike boots');">purchase</button><button onclick="equipBoots('spike boots');">equip</button></div></td>
								</tr>
								<tr>
									<td>feather boots</td>
									<td>120 coins</td>
									<td><div><button onclick="purchaseBoots('feather boots');">purchase</button><button onclick="equipBoots('feather boots');">equip</button></div></td>
								</tr>
								<tr>
									<td>stepping boots</td>
									<td>150 coins</td>
									<td><div><button onclick="purchaseBoots('stepping boots');">purchase</button><button onclick="equipBoots('stepping boots');">equip</button></div></td>
								</tr>
								<tr>
									<td>magnet boots</td>
									<td>170 coins</td>
									<td><div><button onclick="purchaseBoots('magnet boots');">purchase</button><button onclick="equipBoots('magnet boots');">equip</button></div></td>
								</tr>
							</table>
						</div>
						<div class="shop-item">
							<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî F<span class="small">OO</span>D ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
							<table>
								<tr><th>food</th><th>how many</th><th></th></tr>
								<tr>
									<td><label>government meal</label></td>
									<td><label id="government-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('government meal');">devour</button><button onclick="purchaseFood('government meal');">buy (1 coin)</button></td>
								</tr>
								<tr>
									<td><label>apple</label></td>
									<td><label id="apple-howmany">0</label></td>
									<td><div><button onclick="devourFood('apple');">devour</button><button onclick="purchaseFood('apple');">buy (5 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>bread</label></td>
									<td><label id="bread-howmany">0</label></td>
									<td><div><button onclick="devourFood('bread');">devour</button><button onclick="purchaseFood('bread');">buy (10 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>burger</label></td>
									<td><label id="burger-howmany">0</label></td>
									<td><div><button onclick="devourFood('burger');">devour</button><button onclick="purchaseFood('burger');">buy (14 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>cold meal</label></td>
									<td><label id="cold-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('cold meal');">devour</button><button onclick="purchaseFood('cold meal');">buy (19 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>meal</label></td>
									<td><label id="meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('meal');">devour</button><button onclick="purchaseFood('meal');">buy (23 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>warm meal</label></td>
									<td><label id="warm-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('warm meal');">devour</button><button onclick="purchaseFood('warm meal');">buy (27 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>hot meal</label></td>
									<td><label id="hot-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('hot meal');">devour</button><button onclick="purchaseFood('hot meal');">buy (31 coins)</button></div></td>
								</tr>
								<tr>
									<td><label title="crispy gooey homemade mac and cheese">crispy gooey homemade macncheese</label></td>
									<td><label id="crispy-gooey-homemade-mac-and-cheese-howmany">0</label></td>
									<td><div><button onclick="devourFood('crispy gooey homemade mac and cheese');">devour</button><button onclick="purchaseFood('crispy gooey homemade mac and cheese');">buy (34 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>cow brain</label></td>
									<td><label id="cow-brain-howmany">0</label></td>
									<td><div><button onclick="devourFood('cow brain');">devour</button><button onclick="purchaseFood('cow brain');">buy (38 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>filling warm meal</label></td>
									<td><label id="filling-warm-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('filling warm meal');">devour</button><button onclick="purchaseFood('filling warm meal');">buy (41 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>buckwheat pancake</label></td>
									<td><label id="buckwheat-pancake-howmany">0</label></td>
									<td><div><button onclick="devourFood('buckwheat pancake');">devour</button><button onclick="purchaseFood('buckwheat pancake');">buy (47 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>sopping meal</label></td>
									<td><label id="sopping-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('sopping meal');">devour</button><button onclick="purchaseFood('sopping meal');">buy (52 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>emptying cold meal</label></td>
									<td><label id="emptying-cold-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('emptying cold meal');">devour</button><button onclick="purchaseFood('emptying cold meal');">buy (56 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>piping hot meal</label></td>
									<td><label id="piping-hot-meal-howmany">0</label></td>
									<td><div><button onclick="devourFood('piping hot meal');">devour</button><button onclick="purchaseFood('piping hot meal');">buy (59 coins)</button></div></td>
								</tr>
								<tr>
									<td><label title="styrofoam tupperware baggy full of a shrink wrapped reheated rehydrated piping hot filling sloppy sopping warm meal portion">STBFOASWRRPHFSSWMP</label></td>
									<td><label id="styrofoam-tupperware-baggy-full-of-a-shrink-wrapped-reheated-rehydrated-piping-hot-filling-sloppy-sopping-warm-meal-portion-howmany">0</label></td>
									<td><div><button onclick="devourFood('styrofoam tupperware baggy full of a shrink wrapped reheated rehydrated piping hot filling sloppy sopping warm meal portion');">devour</button><button onclick="purchaseFood('styrofoam tupperware baggy full of a shrink wrapped reheated rehydrated piping hot filling sloppy sopping warm meal portion');">buy (62 coins)</button></div></td>
								</tr>
							</table>
						</div>
						<div class="shop-item">
							<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî S<span class="small">TUF</span>F ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
							<table>
								<tr><th>thing</th><th>how many</th><th></th></tr>
								<tr>
									<td><label>ladder</label></td>
									<td><label id="ladder-howmany">0</label></td>
									<td><div><button onclick="placeLadder();">place</button><button onclick="purchaseLadder();">purchase (10 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>tall ladder</label></td>
									<td><label id="tall-ladder-howmany">0</label></td>
									<td><div><button onclick="placeTallLadder();">place</button><button onclick="purchaseTallLadder();">purchase (25 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>scaffolding</label></td>
									<td></td>
									<td><div><button onclick="purchaseScaffolding();">place (1 coin/block)</button></div></td>
								</tr>
								<tr>
									<td><label>trampoline</label></td>
									<td><label id="trampoline-howmany">0</label></td>
									<td><div><button onclick="placeTrampoline();">place</button><button onclick="purchaseTrampoline();">purchase (45 coins)</button></div></td>
								</tr>
								<tr>
									<td><label>lantern</label></td>
									<td>lasts 1m</td>
									<td><div><button onclick="purchaseLantern();">purchase (10 coins)</button></div></td>
								</tr>
							</table>
						</div>
					</div>
					<div id="shop-gems">
						<div class="shop-item">
							<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî A<span class="small">LCHEM</span>Y ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
							<table>
								<th>potion</th><th>time</th><th>how many</th><th></th>
								<tr>
									<td><label>night vision potion</label></td>
									<td>30s</td>
									<td><label id="night-vision-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('night vision potion');">chug</button><button onclick="brewPotion('night vision potion');">brew (2 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>speed potion</label></td>
									<td>10s</td>
									<td><label id="speed-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('speed potion');">chug</button><button onclick="brewPotion('speed potion');">brew (2 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>jumping potion</label></td>
									<td>10s</td>
									<td><label id="jumping-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('jumping potion');">chug</button><button onclick="brewPotion('jumping potion');">brew (3 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>levitation potion</label></td>
									<td>10s</td>
									<td><label id="levitation-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('levitation potion');">chug</button><button onclick="brewPotion('levitation potion');">brew (5 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>regeneration potion</label></td>
									<td>10s</td>
									<td><label id="regeneration-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('regeneration potion');">chug</button><button onclick="brewPotion('regeneration potion');">brew (7 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>spider potion</label></td>
									<td>10s</td>
									<td><label id="spider-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('spider potion');">chug</button><button onclick="brewPotion('spider potion');">brew (8 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>anti gravity potion</label></td>
									<td>10s</td>
									<td><label id="anti-gravity-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('anti gravity potion');">chug</button><button onclick="brewPotion('anti gravity potion');">brew (10 gems)</div></button></td>
								</tr>
								<tr>
									<td><label>invisibility potion</label></td>
									<td>15s</td>
									<td><label id="invisibility-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('invisibility potion');">chug</button><button onclick="brewPotion('invisibility potion');">brew (11 gems)</button></div></td>
								</tr>
								<tr>
									<td><label>bird potion</label></td>
									<td>10s</td>
									<td><label id="bird-potion-howmany">0</label></td>
									<td><div><button onclick="chugPotion('bird potion');">chug</button><button onclick="brewPotion('bird potion');">brew (12 gems)</button></div></td>
								</tr>
							</table>
						</div>
					</div>
				</div>
			</div>
			<div id="obelisk-shop">
				<div class="shop-title">
					<h1>üôõ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OBELISK ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüôô</h1>
				</div>
				<hr>
				<div class="shop-item">
					<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî U<span class="small">PGRADE</span>S ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
					<table>
						<tr><th>upgrade</th><th></th></tr>
						<tr>
							<td><label>health</label></td>
							<td><div><button onclick="obeliskShopUpgradeButton('health');">upgrade (1 totem)</button></div></td>
						</tr>
						<tr>
							<td><label>speed</label></td>
							<td><div><button onclick="obeliskShopUpgradeButton('speed');">upgrade (1 totem)</button></div></td>
						</tr>
						<tr>
							<td><label>jump</label></td>
							<td><div><button onclick="obeliskShopUpgradeButton('jump');">upgrade (1 totem)</button></div></td>
						</tr>
						<tr>
							<td><label>step</label></td>
							<td><div><button onclick="obeliskShopUpgradeButton('step');">upgrade (1 totem)</button></div></td>
						</tr>
					</table>
				</div>
				<div class="shop-item">
					<h2>üôõ‚Äî‚Äî‚Äî‚Äî‚Äî S<span class="small">TUF</span>F ‚Äî‚Äî‚Äî‚Äî‚Äîüôô</h2>
					<table>
						<tr><th>thing</th><th></th></tr>
						<tr>
							<td><label>portal</label></td>
							<td><div><button onclick="openPortal();">open (2 totems)</button></div></td>
						</tr>
					</table>
				</div>
			</div>
		</div>
		<div id="menu">
			<h1 id="menu-title" class="menu-text">forest simulator 3d</h1>
			<button id="menu-button" onclick="playButton();">PLAY</button>
			<div id="seed-wrapper">
				<label for="seed" class="menu-text">Seed:</label>
				<div>
					<p class="menu-text">(Leave blank for random seed)</p>
					<input type="text" value="" id="seed" placeholder="Enter seed...">
				</div>
				<input type="checkbox" id="seed-as-number-checkbox">
				<label for="seed-as-number-checkbox" class="menu-text">As number</label>
			</div>
		</div>
		<div id="hacker-console">
			<input type="text" id="hacker-console-text" onkeydown="hackerConsoleKeyDown(event);">
		</div>
		<div id="notification">

		</div>
		<div id="cursor">
			<div id="cursor-horizontal"></div>
			<div id="cursor-vertical"></div>
			<div id="cursor-center"></div>
		</div>
		<script id="vertex" type="x-shader/x-vertex">
			attribute vec4 a_position;
			attribute vec2 a_texcoord;

			uniform mat4 u_matrix;
			uniform mat4 u_textureMatrix;

			varying vec2 v_texcoord;

			void main() {
				vec4 position = u_matrix * a_position;
				gl_Position = position;
				v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0.0, 1.0)).xy;
			}
		</script>
		<script id="fragment" type="x-shader/x-fragment">
			precision mediump float;

			varying vec2 v_texcoord;

			uniform sampler2D u_texture;

			uniform vec2 u_playerPos;
			uniform vec2 u_blockPos;
			uniform vec2 u_screenSize;
			uniform vec2 u_portalPos;
			uniform float u_portalTime;
			uniform float u_blockSize;
			uniform float u_alpha;
			uniform float u_darknessMin;
			uniform float u_darknessMax;
			uniform float u_darkness;
			uniform float u_ambientDarkness;
			uniform float u_portalSkew;
			uniform float u_whitenessThreshold;
			uniform float u_nightVisionTime;
			uniform float u_lanternTime;
			uniform int u_dimension; // 0-normal 1-upsidedown
			uniform int u_anaglyphMode;
			uniform bool u_removeBlue;
			uniform bool u_removeWhite;

			bool rectIntersection(vec2 p1, vec2 p2, vec2 b1, vec2 b2) {
				float t = 0.0;
				if ((p1.x >= b1.x && p1.x <= b2.x && p1.y >= b1.y && p1.y <= b2.y) || (p2.x >= b1.x && p2.x <= b2.x && p2.y >= b1.y && p2.y <= b2.y)) {
					return true;
				}
				if (p1.x < b1.x && p2.x >= b1.x) { // Left edge
					t = p1.y + (p2.y - p1.y) * (b1.x - p1.x) / (p2.x - p1.x);
					if (t > b1.y && t <= b2.y) {
						return true;
					}
				} else if (p1.x > b2.x && p2.x <= b2.x) { // Right edge
					t = p1.y + (p2.y - p1.y) * (b2.x - p1.x) / (p2.x - p1.x);
					if (t >= b1.y && t <= b2.y) {
						return true;
					}
				}
				if (p1.y < b1.y && p2.y >= b1.y) { // Top edge
					t = p1.x + (p2.x - p1.x) * (b1.y - p1.y) / (p2.y - p1.y);
					if (t >= b1.x && t <= b2.x) {
						return true;
					}
				} else if (p1.y > b2.y && p2.y <= b2.y) {	// Bottom edge
					t = p1.x + (p2.x - p1.x) * (b2.y - p1.y) / (p2.y - p1.y);
					if (t >= b1.x && t <= b2.x) {
						return true;
					}
				}
				return false;
			}
			bool lineIntersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {
				float det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
				if (det == 0.0) {
					return false;
				} else {
					float lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
					float gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;
					return (0.0 < lambda && lambda < 1.0) && (0.0 < gamma && gamma < 1.0);
				}
			}
			vec4 vec4Lerp(vec4 a, vec4 b, vec4 c) {
				return a * (vec4(1.0) - c) + b * c;
			}
			vec3 vec3Lerp(vec3 a, vec3 b, vec3 c) {
				return a * (vec3(1.0) - c) + b * c;
			}
			float lerp(float a, float b, float c) {
				return a * (1.0 - c) + b * c;
			}
			float inverseLerp(float a, float b, float t) {
				return (t - a) / (b - a);
			}
			vec4 invertColor(vec4 color, float factor) {
				return vec4Lerp(color, vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, color.a), vec4(factor));
			}
			vec4 saturation(vec4 color, float factor) {
				return vec4Lerp(color, vec4(vec3((color.r + color.g + color.b) / 3.0), color.a), vec4(factor));
			}
			void main() {
				highp vec2 pixelCoord = vec2(gl_FragCoord.x, gl_FragCoord.y);
				vec4 color = texture2D(u_texture, v_texcoord);
				color.a *= u_alpha;

				if (u_removeBlue) {
					float blueness = clamp(color.b - (color.r + color.g) / 2.0, 0.0, 1.0);
					color.a = blueness > 0.1 ? 0.0 : 1.0 - blueness;
				}
				if (u_removeWhite) {
					float brightness = (color.r + color.g + color.b) / 3.0;
					float a = 1.0 - clamp(inverseLerp(u_whitenessThreshold, 1.0, brightness), 0.0, 1.0);
					color.a = min(a, color.a);
				};

				vec3 darknessColor = vec3(0.0, 0.0, 0.0);
				float ambientDarkness = u_ambientDarkness;
				float darkness = clamp(inverseLerp(u_darknessMin, u_darknessMax, pixelCoord.y) * u_darkness, 0.0, 1.0);
				//bioluminescense://ambientDarkness = min(clamp(distance(pixelCoord, u_playerPos) / (u_blockSize * 3.0) + 0.4, 0.0, 1.0), ambientDarkness);
				if (u_lanternTime > 0.0) {
					float lanternBrightness = clamp(inverseLerp(0.0, 300.0, u_lanternTime), 0.0, 1.0);
					float lanterniness = (1.0 - clamp(distance(pixelCoord, u_playerPos) / (lanternBrightness * 10.0 * u_blockSize), 0.0, 1.0)) * lanternBrightness;
					darknessColor.r = lerp(darknessColor.r, 0.9, lanterniness);
					ambientDarkness = lerp(ambientDarkness, 0.15, lanterniness);
					darkness = lerp(darkness, 0.15, lanterniness);
				}
				if (u_nightVisionTime > 0.0) {
					float nightVisioniness = clamp(inverseLerp(0.0, 1.0, u_nightVisionTime), 0.0, 1.0);
					darknessColor.g = lerp(darknessColor.g, 0.85, nightVisioniness);
					ambientDarkness = lerp(ambientDarkness, lerp(0.3, 0.8, ambientDarkness), nightVisioniness);
					darkness = lerp(darkness, lerp(0.3, 0.8, darkness), nightVisioniness);
				}
				color.rgb = vec3Lerp(color.rgb, darknessColor, vec3(darkness));
				color.rgb = vec3Lerp(color.rgb, darknessColor, vec3(ambientDarkness));
				color.a += darkness;

				bool upsidedownifyPixel = false;
				if (u_portalTime > 0.0) {
					float portalSize = clamp(u_portalTime / 120.0, 0.0, 1.0);
					vec2 portalOffset = vec2(portalSize * u_portalSkew / 2.0, portalSize * 5.0 / 2.0) * vec2(u_blockSize);
					upsidedownifyPixel = lineIntersection(
						pixelCoord,
						u_playerPos,
						u_portalPos + vec2(0.0, 2.5 * u_blockSize) - portalOffset,
						u_portalPos + vec2(0.0, 2.5 * u_blockSize) + portalOffset
					);
				}
				if (u_dimension == 1) {
					upsidedownifyPixel = !upsidedownifyPixel;
				}
				if (upsidedownifyPixel) {
					color = invertColor(color, 1.0);
				}
				if (u_anaglyphMode == 1) {
					color.r = 0.0;
				} else if (u_anaglyphMode == 2) {
					color.g = 0.0;
					color.b = 0.0;
				}
				gl_FragColor = color;
			}
		</script>
		<script src="./m4.js"></script>
		<script type="application/javascript">
			const canvas = document.getElementById("canvas");
			canvas.width = innerWidth;
			canvas.height = innerHeight;
			const canvas2 = document.getElementById("canvas2");
			canvas2.width = innerWidth;
			canvas2.height = innerHeight;
			
			document.getElementById("canvas-wrapper").focus();
	
			var blockSize = 50;
	
			const cyrb53 = (str, seed = 0) => {
				let h1 = 0xdeadbeef ^ seed,
					h2 = 0x41c6ce57 ^ seed;
				for (let i = 0, ch; i < str.length; i++) {
					ch = str.charCodeAt(i);
					h1 = Math.imul(h1 ^ ch, 2654435761);
					h2 = Math.imul(h2 ^ ch, 1597334677);
				};
				
				h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
				h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
				
				return 4294967296 * (2097151 & h2) + (h1 >>> 0);
			};
			const mb32 = {
				new: function(a=Math.floor(Math.random() * 0x80000000), randoms=0) {
					var generator = {};
					generator.seed = a;
					if (typeof a === "string") {
						a = cyrb53(a);
					};
					generator.seedNumber = a;
					generator.a = a;
					generator.randoms = randoms;
					for (let i = 0; i < randoms; i++) {
						generator.a |= 0;
						generator.a += 0x6D2B79F5 | 0;
					};
					return generator;
				},
				rng: function(generator) {
					generator.a |= 0;
					generator.a += 0x6D2B79F5 | 0;
					var t = Math.imul(generator.a ^ generator.a >>> 15, 1 | generator.a);
					t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
					generator.randoms++;
					return ((t ^ t >>> 14) >>> 0) / 4294967296;
				},
				setRandoms: function(generator, howmany) {
					generator.randoms = howmany;
					generator.a = generator.seedNumber;
					for (let i = 0; i < howmany; i++) {
						generator.a |= 0;
						generator.a += 0x6D2B79F5 | 0;
					};
				}
			};
			class WebGLRenderer {
				constructor(canvas) {
					this.gl = canvas.getContext("webgl", {alpha: false});
	
					// init
					this.gl.viewport(0, 0, canvas.width, canvas.height);
					this.gl.clearColor(0, 0, 0, 1);
					this.gl.clear(this.gl.COLOR_BUFFER_BIT);
					this.gl.enable(this.gl.BLEND);
					this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
					this.textures = {};
				
					// get shader code
					this.vertexCode = document.getElementById("vertex").firstChild.nodeValue;
					this.fragmentCode = document.getElementById("fragment").firstChild.nodeValue;
	
					// create shaders and program
					this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
					this.gl.shaderSource(this.vertexShader, this.vertexCode);
					this.gl.compileShader(this.vertexShader);
					
					this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
					this.gl.shaderSource(this.fragmentShader, this.fragmentCode);
					this.gl.compileShader(this.fragmentShader);
	
					this.program = this.gl.createProgram();
					this.gl.attachShader(this.program, this.vertexShader);
					this.gl.attachShader(this.program, this.fragmentShader);
					this.gl.linkProgram(this.program);
	
					this.positionLocation = this.gl.getAttribLocation(this.program, "a_position");
					this.texcoordLocation = this.gl.getAttribLocation(this.program, "a_texcoord");
	
					// lookup uniforms
					this.matrixLocation = this.gl.getUniformLocation(this.program, "u_matrix");
					this.textureMatrixLocation = this.gl.getUniformLocation(this.program, "u_textureMatrix");
					this.textureLocation = this.gl.getUniformLocation(this.program, "u_texture");
					this.playerPosLocation = this.gl.getUniformLocation(this.program, "u_playerPos");
					this.portalTimeLocation = this.gl.getUniformLocation(this.program, "u_portalTime");
					this.portalPosLocation = this.gl.getUniformLocation(this.program, "u_portalPos");
					this.screenSizeLocation = this.gl.getUniformLocation(this.program, "u_screenSize");
					this.blockSizeLocation = this.gl.getUniformLocation(this.program, "u_blockSize");
					this.dimensionLocation = this.gl.getUniformLocation(this.program, "u_dimension");
					this.alphaLocation = this.gl.getUniformLocation(this.program, "u_alpha");
					this.darknessMinLocation = this.gl.getUniformLocation(this.program, "u_darknessMin");
					this.darknessMaxLocation = this.gl.getUniformLocation(this.program, "u_darknessMax");
					this.darknessLocation = this.gl.getUniformLocation(this.program, "u_darkness");
					this.ambientDarknessLocation = this.gl.getUniformLocation(this.program, "u_ambientDarkness");
					this.removeBlueLocation = this.gl.getUniformLocation(this.program, "u_removeBlue");
					this.portalSkewLocation = this.gl.getUniformLocation(this.program, "u_portalSkew");
					this.removeWhiteLocation = this.gl.getUniformLocation(this.program, "u_removeWhite");
					this.whitenessThresholdLocation = this.gl.getUniformLocation(this.program, "u_whitenessThreshold");
					this.nightVisionTimeLocation = this.gl.getUniformLocation(this.program, "u_nightVisionTime");
					this.lanternTimeLocation = this.gl.getUniformLocation(this.program, "u_lanternTime");
					this.anaglyphModeLocation = this.gl.getUniformLocation(this.program, "u_anaglyphMode");
					
					this.positionBuffer = this.gl.createBuffer();
					this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
					this.positions = [
						0, 0,
						0, 1,
						1, 0,
						1, 0,
						0, 1,
						1, 1,
					];
					this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.positions), this.gl.STATIC_DRAW);
	
					this.texcoordBuffer = this.gl.createBuffer();
					this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
					this.texcoords = [
						0, 0,
						0, 1,
						1, 0,
						1, 0,
						0, 1,
						1, 1,
					];
					this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.texcoords), this.gl.STATIC_DRAW);
	
					this.defaultTexture = this.loadImageAndCreateTextureInfo("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAjSURBVBhXY/zP8J8BBhiBEAaYoDQGIF0CYSgQINtHNTsYGAA9/gQN0D1U/wAAAABJRU5ErkJggg==");
					// errors
					if (!this.gl.getShaderParameter(this.vertexShader, this.gl.COMPILE_STATUS)) alert(this.gl.getShaderInfoLog(this.vertexShader));
					if (!this.gl.getShaderParameter(this.fragmentShader, this.gl.COMPILE_STATUS)) alert(this.gl.getShaderInfoLog(this.fragmentShader));
					if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) alert(this.gl.getProgramInfoLog(this.program));
					this.gl.validateProgram(this.program);
					if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) alert(this.gl.getProgramInfoLog(this.program));
				};
	
				loadTextures(textures) {
					for (let texture in textures) {
						this.textures[texture] = this.loadImageAndCreateTextureInfo(textures[texture], texture);
					};
				};
				getTexture(texture) {
					return (typeof this.textures[texture] !== "undefined") ? this.textures[texture] : this.defaultTexture;
				};
				loadImageAndCreateTextureInfo(url, name="tex") {
					var tex = this.gl.createTexture();
					this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
					this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 255, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 0, 255, 255]));
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
	
					var textureInfo = {
						width: 2,
						height: 2,
						texture: tex,
						name: name
					};
					var img = new Image();
					img.addEventListener("load", () => {
						textureInfo.width = img.width;
						textureInfo.height = img.height;
					
						this.gl.bindTexture(this.gl.TEXTURE_2D, textureInfo.texture);
						this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
					});
					img.src = url;
					return textureInfo;
				};
				colorTexture(r, g, b, a) {
					var tex = this.gl.createTexture();
					this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
					this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([r * 255, g * 255, b * 255, a * 255]));
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
					this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
					return {
						width: 1,
						height: 1,
						texture: tex,
						name: [r, g, b, a]
					};
				};
				drawImage(texInfo, dstX=0, dstY=0, dstWidth=blockSize, dstHeight=blockSize, uvX=0, uvY=0, uvWidth=1, uvHeight=1, settings={}) {
					uvX %= 1;
					uvX *= texInfo.width;
					uvY %= 1;
					uvY *= texInfo.height;
					uvWidth *= texInfo.width;
					uvHeight *= texInfo.height;
					this.gl.useProgram(this.program);

					this.gl.uniform2fv(this.playerPosLocation, [(playerX - cameraX) * blockSize, (playerY + 1 - cameraY) * blockSize + this.gl.canvas.height]);
					this.gl.uniform1f(this.portalTimeLocation, portalTime);
					this.gl.uniform2fv(this.portalPosLocation, [(portalX - cameraX) * blockSize, (getRowY(level.rows, portalX) - cameraY) * blockSize + this.gl.canvas.height]);
					this.gl.uniform2fv(this.screenSizeLocation, [this.gl.canvas.width, this.gl.canvas.height]);
					this.gl.uniform1f(this.blockSizeLocation, blockSize);
					this.gl.uniform1i(this.dimensionLocation, ["normal", "upside down"].indexOf(dimension));
					this.gl.uniform1f(this.alphaLocation, settings.alpha ?? 1);
					this.gl.uniform1f(this.darknessMinLocation, this.gl.canvas.height - (dstY + (settings.darknessMin ?? 0) * dstHeight));
					this.gl.uniform1f(this.darknessMaxLocation, this.gl.canvas.height - (dstY + (settings.darknessMax ?? 1) * dstHeight));
					this.gl.uniform1f(this.darknessLocation, settings.darkness ?? 0);
					this.gl.uniform1f(this.ambientDarknessLocation, (settings.sky ?? false) ? 0 : lerp(0, 0.99, getDarkness(gameTime)));
					this.gl.uniform1i(this.removeBlueLocation, settings.removeBlue ?? 0);
					this.gl.uniform1f(this.portalSkewLocation, portalSkew);
					this.gl.uniform1i(this.removeWhiteLocation, settings.removeWhite ?? 0);
					this.gl.uniform1f(this.whitenessThresholdLocation, settings.whitenessThreshold ?? 0.95);
					this.gl.uniform1f(this.nightVisionTimeLocation, potions["night vision potion"].time);
					this.gl.uniform1f(this.lanternTimeLocation, lanternTime);
					this.gl.uniform1i(this.anaglyphModeLocation, anaglyphMode);
					
					this.gl.bindTexture(this.gl.TEXTURE_2D, texInfo.texture);

					this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
					this.gl.enableVertexAttribArray(this.positionLocation);
					this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, this.gl.FALSE, 2 * Float32Array.BYTES_PER_ELEMENT, 0);

					this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);
					this.gl.enableVertexAttribArray(this.texcoordLocation);
					this.gl.vertexAttribPointer(this.texcoordLocation, 2, this.gl.FLOAT, this.gl.FALSE, 2 * Float32Array.BYTES_PER_ELEMENT, 0);

					var matrix = m4.orthographic(0, this.gl.canvas.width, this.gl.canvas.height, 0, -1, 1);
					matrix = m4.translate(matrix, dstX, dstY, 0);
					matrix = m4.scale(matrix, dstWidth, dstHeight, 1);
					this.gl.uniformMatrix4fv(this.matrixLocation, false, matrix);
					var texMatrix = m4.translation(uvX / texInfo.width, uvY / texInfo.height, 0);
					texMatrix = m4.scale(texMatrix, uvWidth / texInfo.width, uvHeight / texInfo.height, 1);
					this.gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);
					this.gl.uniform1i(this.textureLocation, 0);
					this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
				};
				draw() {
					this.gl.clear(this.gl.COLOR_BUFFER_BIT);
					
					let skyImage = (getDarkness(gameTime) < 0.25 && getLayer(playerY) < 11 && getLayer(playerY) > -11) ? "skyDay" : "skyNight";
					this.drawImage(this.getTexture(skyImage), 0, 0, this.gl.canvas.width, this.gl.canvas.height, 0, 0, 1, 1, {sky: true});

					let cloudsScroll = 1 / 8;
					let cloudsOffset = (850 - cameraY) * -blockSize * cloudsScroll;
					this.drawImage(this.getTexture("clouds"), 0, cloudsOffset,this.gl.canvas.width, this.gl.canvas.height, cameraX / (this.gl.canvas.width / blockSize / cloudsScroll) + gameTime / 240, 0, 1, 1, {removeBlue: 1});
					let stoneBackgroundScroll = 1 / 4;
					let stoneBackgroundOffset = (750 - cameraY) * -blockSize * stoneBackgroundScroll;
					this.drawImage(this.getTexture("stoneBackground"), 0, Math.max(stoneBackgroundOffset, 0), this.gl.canvas.width, this.gl.canvas.height - Math.max(stoneBackgroundOffset, 0), cameraX / (this.gl.canvas.width / blockSize / stoneBackgroundScroll), (Math.max(stoneBackgroundOffset, 0) - stoneBackgroundOffset) * stoneBackgroundScroll / this.gl.canvas.height, 1, (this.gl.canvas.height - Math.max(stoneBackgroundOffset, 0)) / this.gl.canvas.height / 4);
					
					this.drawImage(this.getTexture("hills"), 0, stoneBackgroundOffset, this.gl.canvas.width, this.gl.canvas.height, cameraX / (this.gl.canvas.width / blockSize / stoneBackgroundScroll), 0.325, 1, 0.675);
	
					let rowBuffer = range(Math.floor(cameraX), Math.floor(cameraX + this.gl.canvas.width / blockSize));
					let deltaRow = Math.floor(Math.max(1 / blockSize, 1));
					for (let i = 0; i < level.terrainFeatures.length; i += deltaRow) {
						if (level.terrainFeatures[i] === null) continue;
						if (level.terrainFeatures[i] === "rainbow") {
							let rainbowSize = 100;
							this.drawImage(this.getTexture("rainbow"), (i - cameraX) * blockSize, (level.rows[i] + rainbowSize / 2 - cameraY) * -blockSize, blockSize * rainbowSize, blockSize * rainbowSize, 0, 0, 1, 1);
						} else if (level.terrainFeatures[i] === "tree1") {
							this.drawImage(this.getTexture("tree1"), (i - 1.5 - cameraX) * blockSize, (level.rows[i] + 10 - cameraY) * -blockSize, blockSize * 4, blockSize * 10, 0, 0, 1, 1, {removeWhite: 1, whitenessThreshold: 0.5});
						};
					};
	
					let bakedRows = getBakedRows();
					// grass
					for (let i = 0; i < rowBuffer.length; i += deltaRow) {
						let rowYBlocks = getRowY(level.rows, rowBuffer[i]);
						let layer = getLayer(rowYBlocks);
						let footprinty = (layer === 9) && rowYBlocks < getRowY(level.originalRows, rowBuffer[i]);
						let ice = (layer === 9) && Math.round((rowYBlocks - 900) * 1000) / 1000 <= Math.round((getRowY(level.originalRows, rowBuffer[i]) - 900) * 0.9 * 1000) / 1000;
						let groundImage = footprinty ? (ice ? "snowMegaFootprinty" : "snowFootprinty") : layers[layer][0];

						let rowY = (rowYBlocks - cameraY) * -blockSize;
						let bakedRowY = (rowYBlocks - cameraY) * -blockSize;
						let groundUVSize = 25;
						if (rowY < this.gl.canvas.height) {
							let height = this.gl.canvas.height - Math.max(rowY, 0);
							let darknessTop = height - (this.gl.canvas.height - ((rowYBlocks + (level.waterLevel[rowBuffer[i]] ?? 0) * (15 / waterDarkness)) - cameraY) * -blockSize);
							this.drawImage(
								this.getTexture(groundImage),
								(rowBuffer[i] - cameraX) * blockSize,
								Math.max(rowY, 0),
								blockSize * deltaRow,
								height,
								rowBuffer[i] / groundUVSize,
								((Math.max(rowY, 0) - rowY) / blockSize - rowYBlocks) / groundUVSize,
								1 / groundUVSize,
								height / blockSize / groundUVSize,
								{darkness: 1, darknessMin: darknessTop / height, darknessMax: (darknessTop + blockSize * 15) / height}
							);
						};
						
						if (rowBuffer[i] >= 0 && rowBuffer[i] < level.rows.length) {
							switch (level.features[rowBuffer[i]]) {
								case 0:
									break;
								case 1:
									this.drawImage(this.getTexture("coin"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
									break;
								case 2:
									this.drawImage(this.getTexture("gem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
									break;
								case 3:
									this.drawImage(this.getTexture("ladder"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 4, blockSize, blockSize * 4);
									break;
								case 4:
									this.drawImage(this.getTexture("ladder"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 6, blockSize, blockSize * 6);
									break;
								case 5:
									this.drawImage(this.getTexture("wall"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 5, blockSize, blockSize * 5, 0, 0, 1, 5);
									this.drawImage(this.getTexture("stone"), (rowBuffer[i] - 0.1 - cameraX) * blockSize, rowY - blockSize * 5, blockSize * 1.2, blockSize * 0.2, 0, 0, 1.2, 0.2);
									break;
								case 7:
									this.drawImage(this.getTexture("sentryBarracks"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 3, blockSize, blockSize * 3);
									break;
								case 8:
									this.drawImage(this.getTexture("sentryBarracks"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 3, blockSize, blockSize * 3);
									break;
								case 9:
									this.drawImage(this.getTexture("pitfall"), (rowBuffer[i] - cameraX) * blockSize, rowY, blockSize, blockSize * 0.5);
									break;
								case 10:
									this.drawImage(this.getTexture("dybbukBox"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize, 0.205, 0.216, 0.262, 0.433);
									break;
								case 11:
									this.drawImage(this.getTexture("dybbukBoxOpen"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
									break;
								case 12:
									this.drawImage(this.getTexture("totem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
									break;
								case 16:
									this.drawImage(this.getTexture("ruinedObelisk"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 4, blockSize, blockSize * 4);
									break;
								case 17:
									this.drawImage(this.getTexture("timeMachine"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 2, blockSize, blockSize * 2);
									break;
								case 18:
									this.drawImage(this.getTexture("trampoline"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
									break;
								case 19:
									this.drawImage(this.getTexture("humanoidBody"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 4, blockSize, blockSize * 4);
									this.drawImage(this.getTexture("humanoidFace"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 4, blockSize, blockSize * 4, 0, 0, 1, 1, {alpha: getDarkness(gameTime), sky: 1});
									break;
								default:
									this.drawImage(this.getTexture("error"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
							};
							let featureEntity = level.featureEntities[rowBuffer[i]];
							if (featureEntity) {
								switch (featureEntity.type) {
									case "obelisk":
										this.drawImage(this.getTexture("obelisk"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 4 - featureEntity.yOffset * blockSize, blockSize, blockSize * 4 - featureEntity.yOffset * -blockSize, 0.43, 0.1, 0.15, (1 + featureEntity.yOffset / 4) * 0.7);
										break;
									case "scaffolding":
										this.drawImage(this.getTexture("scaffolding"), (rowBuffer[i] - cameraX) * blockSize, rowY - featureEntity.height * blockSize, blockSize, featureEntity.height * blockSize, 0.237, 0.032, 0.525, 0.934);
										break;
									case "sentry house":
										switch (featureEntity.variant) {
											case 1:
												this.drawImage(this.getTexture("sentryHouse1"), (rowBuffer[i] - 0.5 - cameraX) * blockSize, rowY - blockSize * 3, blockSize * 2, blockSize * 3, 0, 0.25, 0.7, 0.4);
												break;
											case 2:
												this.drawImage(this.getTexture("sentryHouse2"), (rowBuffer[i] - 0.5 - cameraX) * blockSize, rowY - blockSize * 3, blockSize * 2, blockSize * 3, 0, 0, 1, 1);
												break;
											case 3:
												this.drawImage(this.getTexture("sentryHouse3"), (rowBuffer[i] - 0.5 - cameraX) * blockSize, rowY - blockSize * 3, blockSize * 2, blockSize * 3, 0, 0, 1, 1);
												break;
											case 4:
												this.drawImage(this.getTexture("sentryHouse4"), (rowBuffer[i] - 0.5 - cameraX) * blockSize, rowY - blockSize * 3, blockSize * 2, blockSize * 3, 0, 0, 1, 1);
												break;
											case 5:
												this.drawImage(this.getTexture("sentryHouse5"), (rowBuffer[i] - 0.5 - cameraX) * blockSize, rowY - blockSize * 3, blockSize * 2, blockSize * 3, 0, 0, 1, 1);
												break;
										};
										break;
									case "sentry well":
										let wellY = (Math.min(getRowY(level.rows, rowBuffer[i] - 1), getRowY(level.rows, rowBuffer[i] + 1)) - cameraY) * -blockSize;
										this.drawImage(this.getTexture("sentryWell"), (rowBuffer[i] - cameraX) * blockSize, wellY - blockSize * 3, blockSize, blockSize * 3, 0, 0, 1, 1);
										this.drawImage(this.getTexture("sentryWellPipe"), (rowBuffer[i] - cameraX) * blockSize, wellY, blockSize, this.gl.canvas.height - wellY, 0, 0, 1, (this.gl.canvas.height - wellY) / blockSize);
										break;
									case "mystery crate":
										this.drawImage(this.getTexture("mysteryCrate"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
										break;
									case "burlap sack":
										this.drawImage(this.getTexture("burlapSack"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
										break;
									case "pot of gold":
										this.drawImage(this.getTexture("potOfGold"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
										break;
									case "four leaf clover":
										this.drawImage(this.getTexture("fourLeafClover"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
										break;
									default:
										this.drawImage(this.getTexture("error"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize, blockSize, blockSize);
								};
							};
							let golem = level.golems[rowBuffer[i]];
							if (golem) {
								switch (golem.type) {
									case "golem":
										this.drawImage(this.getTexture("golem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 3 - golem.yOffset * blockSize, blockSize, blockSize * 3 - golem.yOffset * -blockSize, 0, 0, 1, 1 + (golem.yOffset / 3));
										break;
									case "russet golem":
										this.drawImage(this.getTexture("russetGolem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 6 - golem.yOffset * blockSize, blockSize, blockSize * 6 - golem.yOffset * -blockSize, 0, 0, 1, 1 + (golem.yOffset / 6));
										break;
									case "aqua golem":
										this.drawImage(this.getTexture("aquaGolem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 9 - golem.yOffset * blockSize, blockSize, blockSize * 9 - golem.yOffset * -blockSize, 0, 0, 1, 1 + (golem.yOffset / 9));
										break;
									case "mecha golem":
										this.drawImage(this.getTexture("mechaGolem"), (rowBuffer[i] - 1 - cameraX) * blockSize, rowY - blockSize * 12 - golem.yOffset * blockSize, blockSize * 3, blockSize * 12 - golem.yOffset * -blockSize, 0.298, 0.007, 0.324, 0.919 + (golem.yOffset / 12));
										break;
									case "celestial golem":
										this.drawImage(this.getTexture("celestialGolem"), (rowBuffer[i] - cameraX) * blockSize, rowY - blockSize * 100 - golem.yOffset * blockSize, blockSize, blockSize * 100 - golem.yOffset * -blockSize, 0, 0, 1, 1 + (golem.yOffset / 100));
										break;
								};
							};
						};
					};
					if (potions["invisibility potion"].time <= 0) {
						let animatedGuyImage = dead ? "guyDead" : (inLadder ? "guyClimbingLadder" : (flying ? "guyFlying" : (onGround ? (Math.abs(playerXV) > 0.1 ? "guyRunning" : "guy") : (playerYV <= 0 ? "guyFalling" : "guyJumping"))));
						this.drawImage(this.getTexture(document.getElementById("animations-checkbox").checked ? animatedGuyImage : "guy"), (playerX - 0.5 - cameraX) * blockSize, (playerY + 2 - cameraY) * -blockSize, blockSize, blockSize * 2);
					};
					if (dybbukTime > 0) {
						this.drawImage(this.getTexture("dybbuk"), (playerX - 0.5 - cameraX) * blockSize, (playerY + 2 - cameraY) * -blockSize, blockSize, blockSize * 2, 0, 0, 1, 1, {alpha: 0.5});
					};
					if (document.getElementById("grim-reaper-checkbox").checked) {
						let grimReaperX = lerp(playerX - 1, playerX - 100, health / maxHealth) + 0.5;
						let grimReaperY1 = getRowY(bakedRows, getHittableRows(Math.floor(grimReaperX - 1) + 0.5).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b)) + 3 - cameraY;
						let grimReaperY2 = getRowY(bakedRows, getHittableRows(Math.ceil(grimReaperX) - 0.5).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b)) + 3 - cameraY;
						this.drawImage(this.getTexture("grimReaper"), (Math.floor(grimReaperX - 1) - cameraX) * blockSize, grimReaperY1 * -blockSize, blockSize, blockSize * 3, 0, 0, 1, 1, {alpha: 1 - (grimReaperX) % 1});
						this.drawImage(this.getTexture("grimReaper"), (Math.floor(grimReaperX) - cameraX) * blockSize, grimReaperY2 * -blockSize, blockSize, blockSize * 3, 0, 0, 1, 1, {alpha: (grimReaperX) % 1});
					};

					for (let mob of level.mobs) {
						if ((mob.x + 0.5 - cameraX) * blockSize > 0 && (mob.x - 0.5 - cameraX) * blockSize < this.gl.canvas.width) {
							switch (mob.type) {
								case "sentry":
									if (mob.age >= 120) {
										this.drawImage(this.getTexture("sentry"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4);
									};
									break;
								case "mimic":
									if (mob.mimicking) {
										switch (mob.mimicTarget) {
											case "coin":
												this.drawImage(this.getTexture("coin"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 1 - cameraY) * -blockSize, blockSize, blockSize);
												break;
											case "gem":
												this.drawImage(this.getTexture("gem"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 1 - cameraY) * -blockSize, blockSize, blockSize);
												break;
											default:
												this.drawImage(this.getTexture("error"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 1 - cameraY) * -blockSize, blockSize, blockSize);
										};
									} else {
										if (mob.deltaX === 0) {
											this.drawImage(this.getTexture("mimic"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4, 0.435, 0.278, 0.144, 0.548);//idle
										} else if (mob.deltaX > 0.19) {
											this.drawImage(this.getTexture("mimic"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4, 0.054, 0.27, 0.174, 0.686);//rightbig
										} else if (mob.deltaX > 0) {
											this.drawImage(this.getTexture("mimic"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4, 0.216, 0.277, 0.175, 0.579);//right
										} else if (mob.deltaX < -0.19) {
											this.drawImage(this.getTexture("mimic"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4, 0.759, 0.249, 0.2, 0.686);//leftbig
										} else if (mob.deltaX < 0) {
											this.drawImage(this.getTexture("mimic"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 4 - cameraY) * -blockSize, blockSize, blockSize * 4, 0.613, 0.262, 0.167, 0.578);//left
										};
									};
									break;
								case "leprechaun":
									this.drawImage(this.getTexture("leprechaun"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 1.5 - cameraY) * -blockSize, blockSize, blockSize * 1.5);
									break;
								case "possessed doll":
									this.drawImage(this.getTexture(mob.possessed ? "possessedDollStanding" : "possessedDollSitting"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 1.5 - cameraY) * -blockSize, blockSize, blockSize * 1.5);
									break;
								case "merchant":
									this.drawImage(this.getTexture("merchant"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 3 - cameraY) * -blockSize, blockSize, blockSize * 3, 0.145, 0.111, 0.707, 0.8);
									break;
								default:
									this.drawImage(this.getTexture("error"), (mob.x - 0.5 - cameraX) * blockSize, (mob.y + 2 - cameraY) * -blockSize, blockSize, blockSize * 2);
							};
						};
					};
					for (let i = 0; i < rowBuffer.length; i += deltaRow) {
						if (level.waterLevel[rowBuffer[i]] > 0) {
							let waveOffset = Math.max(Math.sin(gameTime * 2 + rowBuffer[i] / 5) * 0.25, -level.waterLevel[rowBuffer[i]]);
							let waterUVSize = 25;
							let waterY = (bakedRows[rowBuffer[i]] + level.waterLevel[rowBuffer[i]] + waveOffset - cameraY) * -blockSize;
							let waterHeight = Math.min((bakedRows[rowBuffer[i]] - cameraY) * -blockSize - waterY, this.gl.canvas.height - Math.min(waterY, 0));
	
							if (waterY < this.gl.canvas.height) {
								let yOffset = Math.max(waterY, 0) - waterY;
								this.drawImage(
									this.getTexture("water"),
									(rowBuffer[i] - cameraX) * blockSize,
									Math.max(waterY, 0),
									blockSize * deltaRow,
									waterHeight - yOffset,
									rowBuffer[i] / waterUVSize,
									(Math.max(waterY, 0) - waterY) / blockSize / waterUVSize,
									1 / waterUVSize,
									(waterHeight + (waterY - Math.max(waterY, 0))) / blockSize / waterUVSize,
									{alpha: 0.5, darkness: 1, darknessMin: -yOffset / waterHeight, darknessMax: (waterDarkness * blockSize - yOffset - (waveOffset * blockSize)) / ((bakedRows[rowBuffer[i]] - cameraY) * -blockSize - waterY)}
								);
							};
						};
					};
	
					/*if (timeTraveling) {
						ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
						ctx.fillRect(0, (gameTime * 300) % canvas.height, canvas.width, 1);
						ctx.fillStyle = "black";
						ctx.fillRect(Math.random() * canvas.width, 0, 1, canvas.height);
						let howManyNoises = 500;
						let noiseBrightness = Math.random() * 255;
						ctx.fillStyle = "rgb(" + noiseBrightness + ", " + noiseBrightness + ", " + noiseBrightness + ")";
						for (let i = 0; i < howManyNoises; i++) {
							ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() + 1, Math.random() + 1);
						};
					};*/
	
					if (health / maxHealth < 0.1) {
						this.drawImage(this.getTexture("blood"), 0, 0, this.gl.canvas.width, this.gl.canvas.height, 0, 0, 1, 1, {alpha: clamp(1 - (health / maxHealth) / 0.1, 0, 1), sky: 1});
					};
				};
			};
			const renderer = new WebGLRenderer(canvas);
			const renderer2 = new WebGLRenderer(canvas2);
	
			var keysDown = [];
			function isDown(key) {
				return keysDown[key] ?? false;
			};
			function cot(x) {
				return 1 / Math.tan(x);
			};
			class Joystick {
				constructor(element) {
					this.angle = 0;
					this.strength = 0;
					this.isMouseDown = false;
					this.element = element;
				};
				mouseMove(e) {
					if (!shop) {
						if (e.touches) {
							e = e.touches[0];
						};
						let coords = this.coordinates(e.clientX, e.clientY);
						let rect = this.element.getBoundingClientRect();
						let xy = this.coordinates(rect.x, rect.y);
						if (this.isMouseDown) {
							this.angle = Math.atan2(coords[0], coords[1]);
							this.strength = clamp(Math.sqrt((coords[0] - (xy[0] + rect.width / 2)) ** 2 + (coords[1] - (xy[1] + rect.height / 2)) ** 2) / 100, 0, 1);
						};
						this.updateCircle();
					};
				};
				getAmplitudes() {
					let x = clamp(Math.tan(this.angle), -1, 1);
					let y = clamp(cot(this.angle), -1, 1);
					if (this.angle > -Math.PI && this.angle < -Math.PI / 2) {
						x *= -1;
						gems = 0;
					};
					if (this.angle > Math.PI / 2 && this.angle < Math.PI) {
						x *= -1;
						y *= -1;
						gems = 1
					};
					if (this.angle > 0 && this.angle < Math.PI / 2) {
						y *= -1;
						gems = 3;
					};
					return {
						"x": x * this.strength,
						"y": y * this.strength
					};
				};
				mouseUp(e) {
					if (!shop) {
						if (e.touches) {
							e = e.touches[0];
						};
						this.isMouseDown = false;
						this.angle = 0;
						this.strength = 0;
						this.updateCircle();
					};
				};
				mouseDown(e) {
					if (!shop) {
						if (e.touches) {
							e = e.touches[0];
						};
						this.isMouseDown = true;
						this.mouseMove(e);
					};
				};
				coordinates(x, y) {
					let rect = this.element.getBoundingClientRect();
					return [x - (rect.x + rect.width / 2), y - (rect.y + rect.height / 2)];
				};
				updateCircle() {
					document.getElementById("circle-thing").style.transform = "translate(" + (Math.sin(this.angle) * this.strength * 100) + "px, " + (Math.cos(this.angle) * this.strength * 100) + "px)";
				};
			};
			class SoundSystem {
				constructor() { /* {sound1: https://s.com/sound1.mp3,...} */
					this.activeSounds = [];
				};
				emitSound(sound, origin) {
					if (distance(origin, [playerX, playerY] < 150)) {
						var newSound = sound.createInstance(origin);
						newSound.element.addEventListener("ended", e => {
							this.activeSounds.splice(this.activeSounds.indexOf(newSound), 1);
						});

						this.activeSounds.push(newSound);
						newSound.element.play();
					};
				};
				tickAllSounds() {
					this.activeSounds.forEach(sound => {
						sound.element.volume = 1;
						try {
							sound.falloff(sound.origin);
						} catch (e) {
							console.error("sound origin error");
						};
					});
				};
			};
			class Sound {
				constructor(thing, origin) {
					if (thing instanceof Audio) {
						this.element = thing;
					} else {
						this.element = new Audio(thing);
					};
					this.origin = origin;
				};
				falloff(origin) {
					this.element.volume = 1;
					this.element.volume = clamp(5 * this.element.volume / (2 * Math.PI * distance(origin, [playerX, playerY + 1]) + 1), 0, 1);
				};
				createInstance(origin=this.origin) {
					var soundClone = new Sound(this.element.cloneNode(), origin);
					return soundClone;
				};
			};
			Math.mod = function(a, b) {
				return ((a % b) + b) % b;
			};
			Array.prototype.mean = function() {
				return this.reduce((a, b) => a + b, 0) / this.length;
			};
			const soundSystem = new SoundSystem();
			
			// consts
			const fact = "Marina silva is a brazilian politician and an activist for deforestation and other things.\nShe was a rubber tapper and found that land was being invaded by rubber tappers and she\nstarted protecting thousands of hectares of land.";
			const waterDarkness = 20;
			const missions = [
				{
					"getStartingValue": () => totems,
					"satisfies": function(){return totems - startingValue >= 1},
					"complete": () => {potions["bird potion"].howmany += 5},
					"mission": "collect 1 totem",
					"reward": "+5 bird potions"
				},
				{
					"getStartingValue": () => gems,
					"satisfies": function(startingValue) {return gems - startingValue >= 10},
					"complete": () => {foods["filling warm meal"].howmany += 2},
					"mission": "collect 10 gems",
					"reward": "+2 filling warm meals"
				},
				{
					"getStartingValue": () => playerX,
					"satisfies": function(startingValue) {return Math.abs(playerX - startingValue) >= 500},
					"complete": () => {foods["government meal"].howmany += 80},
					"mission": "travel 500 blocks",
					"reward": "+80 government meals"
				},
				{
					"getStartingValue": () => playerX,
					"satisfies": function(startingValue) {return Math.abs(playerX - startingValue) >= 1000},
					"complete": () => {gems += 20},
					"mission": "travel 1000 blocks",
					"reward": "+20 gems"
				},
				{
					"getStartingValue": () => foods["government meal"].howmany,
					"satisfies": function(startingValue) {return foods["government meal"].howmany - startingValue >= 123},
					"complete": () => {foods["filling warm meal"].howmany += 2},
					"mission": "buy 123 more government meals",
					"reward": "+2 filling warm meals"
				},
				{
					"getStartingValue": () => playerX,
					"satisfies": function(startingValue) {return (playerX - startingValue) <= -250},
					"complete": () => {potions["speed potion"].howmany += 3},
					"mission": "travel 250 blocks backwards",
					"reward": "+3 speed potions"
				}
			];
	
			var game = {
				"playerX": 0.5,
				"playerY": 0,
				"playerXV": 0,
				"playerYV": 0,
				"onGround": false,
				"level": {
					"rows": [],
					"originalRows": [],
					"features": [],
					"octaves": [],
					"mobs": [],
					"featureEntities": [],
					"terrainFeatures": [],
					"waterLevel": [],
					"golems": [],
					"perlinOffset": 0
				},
				"coins": 0,
				"gems": 0,
				"totems": 0,
				"bootses": {
					"hondas":			{bought: true, cost: 0},
					"tennis rackets":	{bought: false, cost: 30},
					"running shoes":	{bought: false, cost: 60},
					"spring boots":		{bought: false, cost: 90},
					"spike boots":		{bought: false, cost: 100},
					"feather boots":	{bought: false, cost: 120},
					"stepping boots":	{bought: false, cost: 150},
					"magnet boots":		{bought: false, cost: 170}
				},
				"foods": {
					"government meal":						{cost: 1, hunger: 0.01, howmany: 0},
					"apple":								{cost: 5, hunger: 0.1, howmany: 0},
					"bread":								{cost: 10, hunger: 0.2, howmany: 0},
					"burger":								{cost: 14, hunger: 0.3, howmany: 0},
					"cold meal":							{cost: 19, hunger: 0.4, howmany: 0},
					"meal":									{cost: 23, hunger: 0.5, howmany: 0},
					"warm meal":							{cost: 27, hunger: 0.6, howmany: 0},
					"hot meal":								{cost: 31, hunger: 0.7, howmany: 0},
					"crispy gooey homemade mac and cheese":	{cost: 34, hunger: 0.8, howmany: 0},
					"cow brain":							{cost: 38, hunger: 0.9, howmany: 0},
					"filling warm meal":					{cost: 41, hunger: 1, howmany: 0},
					
					"buckwheat pancake":																											{cost: 47, hunger: 1.2, howmany: 0},
					"sopping meal":																													{cost: 52, hunger: 1.4, howmany: 0},
					"emptying cold meal":																											{cost: 56, hunger: -0.8, howmany: 0},
					"piping hot meal":																												{cost: 59, hunger: 1.8, howmany: 0},
					"styrofoam tupperware baggy full of a shrink wrapped reheated rehydrated piping hot filling sloppy sopping warm meal portion": 	{cost: 62, hunger: 2, howmany: 0}
				},
				"potions": {
					"night vision potion":	{cost: 2, time: 0, duration: 30, howmany: 0},
					"speed potion":			{cost: 2, time: 0, duration: 10, howmany: 0},
					"jumping potion":		{cost: 3, time: 0, duration: 10, howmany: 0},
					"levitation potion":	{cost: 5, time: 0, duration: 10, howmany: 0},
					"regeneration potion":	{cost: 7, time: 0, duration: 10, howmany: 0},
					"spider potion":		{cost: 8, time: 0, duration: 10, howmany: 0},
					"anti gravity potion":	{cost: 10, time: 0, duration: 10, howmany: 0},
					"invisibility potion":	{cost: 11, time: 0, duration: 15, howmany: 0},
					"bird potion":			{cost: 12, time: 0, duration: 10, howmany: 0}
				},
				"boots": "hondas",
				"health": 1,
				"dead": false,
				"ladders": 0,
				"inLadder": false,
				"inLadderSpeed": 0.1,
				"tallLadders": 0,
				"score": 0,
				"gameTime": 0,
				"dybbukTime": 0,
				"basePlayerSpeed": 0.2,
				"baseJumpHeight": 0.24,
				"maxHealth": 1
			};
			var playerX = 0.5;
			var playerY = 0;
			var playerXV = 0;
			var playerYV = 0;
			var cameraX = playerX - (innerWidth / 2);
			var cameraY = (playerY + 1) - (innerHeight / 2);
			var cameraPanX = 0;
			var cameraPanY = 0;
			var cameraSnapPending = true;
			var onGround = false;
			var layers = {
				"-13": ["sun", 0.07, -0.0175],
				"-12": ["mercury", 0.35, -0.012],
				"-11": ["venus", 0.3, -0.01],
				"-10": ["ice", 0.03, -0.012],
				"-9": ["mountain", 0.1, -0.012],
				"-8": ["stone", 0.35, -0.012],
				"-7": ["grass", 0.35, -0.012],
				"-6": ["dirt", 0.2, -0.012],
				"-5": ["stones", 0.25, -0.012],
				"-4": ["stone", 0.3, -0.012],
				"-3": ["darkStone", 0.35, -0.012],
				"-2": ["magma", 0.23, -0.012],
				"-1": ["lava", 0.1, -0.012],
				"0": ["ironNickelAlloy", 0.14, -0.012],
				"1": ["lava", 0.1, -0.012],
				"2": ["magma", 0.23, -0.012],
				"3": ["darkStone", 0.35, -0.012],
				"4": ["stone", 0.3, -0.012],
				"5": ["stones", 0.25, -0.012],
				"6": ["dirt", 0.2, -0.012],
				"7": ["grass", 0.35, -0.012],
				"8": ["stone", 0.35, -0.012],
				"9": ["snow", 0.12, -0.012],
				"10": ["ice", 0.03, -0.012],
				"11": ["moon", 0.3, -0.007],
				"12": ["mars", 0.25, -0.009],
				"13": ["jupiter", 0.07, -0.0175],
				"14": ["saturn", 0.07, -0.016],
				"15": ["uranus", 0.07, -0.013],
				"16": ["neptune", 0.07, -0.014]
			};
			var level = {
				rows: [],
				originalRows: [],
				features: [],
				octaves: [],
				mobs: [],
				featureEntities: [],
				terrainFeatures: [],
				waterLevel: [],
				golems: [],
				perlinOffset: 0,
				levelRNG: mb32.new(),
				featureRNG: mb32.new()
			};
			var coins = 0;
			var gems = 0;
			var totems = 0;
			var shop = false;
			var bootses = {
				"hondas": {bought: true, cost: 0},
				"tennis rackets": {bought: false, cost: 30},
				"running shoes": {bought: false, cost: 60},
				"spring boots": {bought: false, cost: 90},
				"spike boots": {bought: false, cost: 100},
				"feather boots": {bought: false, cost: 120},
				"stepping boots": {bought: false, cost: 150},
				"magnet boots": {bought: false, cost: 170}
			};
			var foods = {
				"government meal": {cost: 1, hunger: 0.01, howmany: 0},
				"apple": {cost: 5, hunger: 0.1, howmany: 0},
				"bread": {cost: 10, hunger: 0.2, howmany: 0},
				"burger": {cost: 14, hunger: 0.3, howmany: 0},
				"cold meal": {cost: 19, hunger: 0.4, howmany: 0},
				"meal": {cost: 23, hunger: 0.5, howmany: 0},
				"warm meal": {cost: 27, hunger: 0.6, howmany: 0},
				"hot meal": {cost: 31, hunger: 0.7, howmany: 0},
				"crispy gooey homemade mac and cheese": {cost: 34, hunger: 0.8, howmany: 0},
				"cow brain": {cost: 38, hunger: 0.9, howmany: 0},
				"filling warm meal": {cost: 41, hunger: 1, howmany: 0},
	
				"buckwheat pancake": {cost: 47, hunger: 1.2, howmany: 0},
				"sopping meal": {cost: 52, hunger: 1.4, howmany: 0},
				"emptying cold meal": {cost: 56, hunger: -0.8, howmany: 0},
				"piping hot meal": {cost: 59, hunger: 1.8, howmany: 0},
				"styrofoam tupperware baggy full of a shrink wrapped reheated rehydrated piping hot filling sloppy sopping warm meal portion": {cost: 62, hunger: 2, howmany: 0}
			};
			var potions = {
				"night vision potion": {cost: 2, time: 0, duration: 30, howmany: 0},
				"speed potion": {cost: 2, time: 0, duration: 10, howmany: 0},
				"jumping potion": {cost: 3, time: 0, duration: 10, howmany: 0},
				"levitation potion": {cost: 5, time: 0, duration: 10, howmany: 0},
				"regeneration potion": {cost: 7, time: 0, duration: 10, howmany: 0},
				"spider potion": {cost: 8, time: 0, duration: 10, howmany: 0},
				"anti gravity potion": {cost: 10, time: 0, duration: 10, howmany: 0},
				"invisibility potion": {cost: 11, time: 0, duration: 15, howmany: 0},
				"bird potion": {cost: 12, time: 0, duration: 10, howmany: 0}
			};
			var boots = "hondas";
			var health = 1;
			var dead = false;
			var ladders = 0;
			var inLadder = false;
			var inLadderSpeed = 0.1;
			var joystick = new Joystick(document.getElementById("joystick"));
			var controls = {
				up: false,
				down: false,
				left: false,
				right: false
			};
			var tallLadders = 0;
			var score = 0;
			var frameCount = 0;
			var fps = 0;
			var fpsUpdateTime = 0;
			var flying = false;
			var pb = 0;
			var notification = "";
			var notificationTime = 0;
			var gameTime = 0;
			var developerMode = true;
			var dybbukTime = 0;
			var crouching = false;
			var obeliskShop = false;
			var basePlayerSpeed = 0.2;
			var baseJumpHeight = 0.24;
			var maxHealth = 1;
			var resizeGroundUV = true;
			var inWater = false;
			var golems = {
				"golem": {
					width: 1,
					height: 3,
					riseSpeed: 0.01,
					sinkSpeed: -0.01,
					image: "golem",
					spawnOffset: 35
				},
				"russet golem": {
					width: 1,
					height: 6,
					riseSpeed: 0.008,
					sinkSpeed: -0.01,
					image: "russetGolem",
					spawnOffset: 35
				},
				"aqua golem": {
					width: 1,
					height: 9,
					riseSpeed: 0.005,
					sinkSpeed: -0.005,
					image: "russetGolem",
					spawnOffset: 35
				},
				"mecha golem": {
					width: 1,
					height: 12,
					riseSpeed: 0.01,
					sinkSpeed: -0.01,
					image: "mechaGolem",
					spawnOffset: 35
				},
				"celestial golem": {
					width: 1,
					height: 100,
					riseSpeed: 1,
					sinkSpeed: -1,
					image: "celestialGolem",
					spawnOffset: 35
				}
			};
			var baseStepHeight = 0.5;
			var oxygen = 1;
			var playing = false;
			var timeTraveling = false;
			var trampolines = 0;
			var divingSuit = false;
			var oldGamePadMenuButtonPressed = false;
			var oldGamePadAButtonPressed = false;
			var cursorX = innerWidth / 2;
			var cursorY = innerHeight / 2;
			var saveSlotNumber = 0;
			var possessionTime = 0;
			var possessionDoll = null;
			var dimension = "normal";
			var portalX = 0;
			var portalTime = 0;
			var portalSkew = 0;
			var obeliskShopButtonShowing = false;
			var sounds = {
				"sentryIdle": new Sound("./sounds/sentryIdle.mp3"),
				"death": new Sound("./sounds/death.mp3"),
				"sentryAmbient": new Sound("./sounds/sentryAmbient.mp3"),
				"humanoidAmbient": new Sound("./sounds/humanoidAmbient.mp3")
			};
			var lanternTime = 0;
			var scrollShowing = false;
			var anaglyphMode = 1;
	
			function generateOctaves() {
				// octaves
				level.octaves = [];
				for (let i = 0; i < 25; i++) {
					level.octaves.push(perlinNoise1D());
				};
				
				// perin offset
				var tempRows = [];
				for (let i = 0; i < 50000; i++) {
					tempRows[i] = getPerlinHeight(i);
				};
				level.perlinOffset = parseInt(Object.keys(tempRows).sort((a, b) => Math.abs(tempRows[a] - 750) - Math.abs(tempRows[b] - 750))[0]);
			};
			function getPerlinHeight(x) {
				let perlinHeight = 0;
				for (let j = 0; j < level.octaves.length; j++) {
					let amplitude = 1400;
					let wavelength = 4700;
					perlinHeight += ((perlinGetVal(level.octaves[j], (x + level.perlinOffset) / (wavelength / (2 ** j))) - 0.5) * 2 * amplitude) / (2 ** j);
				};
				return perlinHeight;
			};
			function generateLevel() {
				var newRows = 5000;
				let oldLength = level.rows.length;//rows.length === 0 ? -1 : rows.length;
				for (let i = oldLength; i < oldLength + newRows; i++) {
					level.rows[i] = level.originalRows[i] = getPerlinHeight(i);// + (level.rows[i - 1] ?? 0);
					level.featureEntities[i] = null;
					level.golems[i] = null;
				};
	
				// pieces
				let pieces = [ // 0 id 1 chance 2 thingthing
					[1, 0, 1 / 20],
					[2, 0, 1 / 200],
					[5, 0, 1 / 5000],
					[7, 0, 1 / 4000],
					[10, 0, 1 / 2000],
					[12, 0, 1 / 8000],
					[16, 0, 1 / 20000],
					[17, 0, 1 / 20213123123123.000],
					[19, 0, 1 / 35000]
				];
				let currentPieceThing = 0;
				for (let i = 0; i < pieces.length; i++) {
					pieces[i][1] = currentPieceThing;
					currentPieceThing += pieces[i][2];
					pieces[i][2] = currentPieceThing;
				};

				// round stuff and coins n gems
				for (let i = oldLength; i < oldLength + newRows; i++) {// 0-air 1-coin 2-gem 3-ladder 4-tallladder 5-wall 6-mysterycrate 7-sentrybarracks 8-sentrybarracksnosentry 9-pitfall 10-dybbukbox 11-dybbukboxopen 12-totem 13-fourleafclover 14-potofgold 15-burlapsack 16-ruinedobelisk 17-timemachine 18-trampoline 19-humanoid
					level.waterLevel[i] = 0;
					if (mb32.rng(level.featureRNG) < 1 / 1000) {
						level.waterLevel[i] = Math.floor(mb32.rng(level.featureRNG) * 500);
					};
					if (i === 300000000) {
						let trenchDepth = 100;
						let trenchWidth = 19;
						for (let j = -trenchWidth; j <= trenchWidth; j++) {
							if (i + j < level.rows.length && i + j >= 0) {
								let heightOffset = trenchDepth * (Math.sin((Math.PI / trenchWidth) * j + 1.5 * Math.PI) / 2 - 0.5);
								level.rows[i + j] += heightOffset;
								level.waterLevel[i + j] = -heightOffset;
								//notificate((i + j) + " " + heightOffset);
							};
						};
						//level.waterLevel[i] = (trenchDepth * (trenchWidth * 2 + 1)) / 2;
					};
					level.rows[i] = Math.round(level.rows[i]);
					if (level.features[i] === undefined) {
						let featuriness = mb32.rng(level.featureRNG);
						level.features[i] = 0;
						for (let j = 0; j < pieces.length; j++) {
							if (featuriness >= pieces[j][1] && featuriness < pieces[j][2]) {
								level.features[i] = pieces[j][0];
								break;
							};
						};
						//if (1 / 70 && new Set([level.rows[i - 2], level.rows[i - 1], level.rows[i], Math.round(level.rows[i + 1]), Math.round(level.rows[i + 2])]).size === 1) pool.push(9);
						//level.features[i] = pool.length === 0 ? 0 : pool[Math.floor(mb32.rng(level.featureRNG) * pool.length)];
					};
	
					if (mb32.rng(level.featureRNG) < 1 / 30000) {
						let villageWidth = 35;
						let villageFalloff = 10;
						let rowRange = range(Math.max(i - villageWidth, 0), Math.min(i + villageWidth, level.rows.length - 1));
						let rowRangeMean = Math.round(rowRange.map(it => level.rows[it]).mean());
						for (let j of rowRange) {
							let rowHeight = Math.round((level.rows[j] - rowRangeMean) * 0.05 + rowRangeMean);
							let flatness = clamp(villageWidth - Math.abs(j - i), 0, villageFalloff) / villageFalloff;
							if (flatness < 1) {
								level.rows[j] = Math.round(lerp(level.rows[j], rowHeight, flatness));
							} else {
								level.rows[j] = rowHeight;
							};
						};
						for (let j = -(villageWidth - villageFalloff - 5); j < villageWidth - villageFalloff - 5; j += 5) {
							if (mb32.rng(level.featureRNG) < 0.9) {
								placeFeatureEntity("sentry house", i + j, Math.floor(mb32.rng(level.featureRNG) * 5 + 1));
							};
						};
						placeFeatureEntity("sentry well", i);
						level.features[i] = 12;
						level.rows[i] -= 80;
						level.waterLevel[i] += 75;
						level.features[i - (villageWidth - villageFalloff - 1)] = 5;
						level.features[i + (villageWidth - villageFalloff - 1)] = 5;
						if (mb32.rng(level.featureRNG) < 0.5) {
							level.features[i + (villageWidth - villageFalloff - 2)] = 4;
						};
					};

					if (mb32.rng(level.featureRNG) < 1 / 5000) {
						placeGolem("golem", i, false);
					};
					if (mb32.rng(level.featureRNG) < 1 / 10000) {
						placeGolem("russet golem", i, false);
					};
					if (mb32.rng(level.featureRNG) < 1 / 12000) {
						placeGolem("aqua golem", i, false);
					};
					if (mb32.rng(level.featureRNG) < 1 / 17000) {
						placeGolem("mecha golem", i, false);
					};
					if (mb32.rng(level.featureRNG) < 1 / 52000) {
						placeGolem("celestial golem", i, false);
					};
	
					if (mb32.rng(level.featureRNG) < 1 / 5000) {
						spawnMob("mimic", i + 0.5 + (mb32.rng(level.featureRNG) - 0.5) * 1.5, level.rows[i] + (mb32.rng(level.featureRNG) - 0.5) * 1.5);
					};
					if (mb32.rng(level.featureRNG) < 1 / 3000) {
						spawnMob("possessed doll", i + 0.5, level.rows[i]);
					};
					if (mb32.rng(level.featureRNG) < 1 / 3000) {
						level.terrainFeatures[i] = "tree1";
					};
					if (mb32.rng(level.featureRNG) < 1 / 4212133121320.00) {
						level.terrainFeatures[i] = "rainbow";
					};

					if (mb32.rng(level.featureRNG) < 1 / 1000) placeFeatureEntity("mystery crate", i);
					if (mb32.rng(level.featureRNG) < 1 / 4000) placeFeatureEntity("burlap sack", i);
					if (mb32.rng(level.featureRNG) < 1 / 25000) placeFeatureEntity("four leaf clover", i);
				};
				level.originalRows = [...level.rows];
			};
			function getHittableRows(x) {
				hittableRows = [];
				if (Math.mod(x, 1) < 0.5) {
					hittableRows.push(Math.floor(x) - 1);
				};
				hittableRows.push(Math.floor(x));
				if (Math.mod(x, 1) > 0.5) {
					hittableRows.push(Math.floor(x) + 1);
				};
				return hittableRows;
			};
			function clamp(number, min, max) {
				return Math.min(Math.max(number, min), max);
			};
			function getLayer(y) {
				return clamp(Math.floor(y / 100), Math.min(...Object.keys(layers)), Math.max(...Object.keys(layers)));
			};
			function lerp(a, b, c) {
				return a * (1 - c) + b * c;
			};
			function inverseLerp(a, b, c) {
				return c / (b - a) + a;
			};
	
			function perlinNoise1D() {
				let MAX_VERTICES = 1024;
				let r = [];
				for (let i = 0; i < MAX_VERTICES; ++i) {
					r.push(mb32.rng(level.levelRNG));
				};
				return {MAX_VERTICES, r};
			};
			function perlinGetVal(generator, x) {
				let t = x - Math.floor(x);
				let tRemapSmoothstep = t ** 2 * (3 - 2 * t);
				let xMin = Math.floor(x) & (generator.MAX_VERTICES - 1);
				let xMax = (xMin + 1) & (generator.MAX_VERTICES - 1);
				return lerp(generator.r[xMin], generator.r[xMax], tRemapSmoothstep);
			};
			function shopButton() {
				if (shop = !shop) {
					document.getElementById("shop").style.display = "block";
					document.getElementById("save-slot-selector").focus();
					document.getElementById("cursor").style.display = "block";
				} else {
					document.getElementById("shop").style.display = "none";
					document.getElementById("canvas-wrapper").focus();
					document.getElementById("cursor").style.display = "none";
				};
			};
			function obeliskShopButton() {
				if (obeliskShop = !obeliskShop) {
					document.getElementById("obelisk-shop").style.display = "block";
					document.getElementById("cursor").style.display = "block";
				} else {
					document.getElementById("obelisk-shop").style.display = "none";
					document.getElementById("canvas-wrapper").focus();
					document.getElementById("cursor").style.display = "none";
				};
			};
			function equipBoots(bootsreal) {
				if (bootses[bootsreal]?.bought) {
					boots = bootsreal;
				};
			};
			function purchaseBoots(bootsreal) {
				if (!bootses[bootsreal]?.bought) {
					if (coins >= bootses[bootsreal].cost) {
						bootses[bootsreal].bought = true;
						coins -= bootses[bootsreal].cost;
					} else {
						notificate("bankrupt");
					};
				};
			};
			function purchaseFood(food) {
				if (coins >= foods[food].cost) {
					foods[food].howmany++;
					coins -= foods[food].cost;
				} else {
					notificate("bankrupt");
				};
			};
			function devourFood(food) {
				if (foods[food].howmany >= 1) {
					foods[food].howmany--;
					health += foods[food].hunger;
					health = clamp(health, 0, maxHealth);
				};
			};
			function keyDownFunction(e) {
				if (e.repeat) return;
				keysDown[e.key] = true;
				if (e.key === "t") {
					notificate(fact);
				} else if (e.key === "r" && developerMode) {
					playerXV = 0;
					playerYV = 0;
					playerX = 0.5;
					playerY = getRowY(level.rows, 0) ?? 0;
					cameraSnapPending = true;
					gameTime = 0;
				} else if (e.key === "e") {
					let ruinedObeliskRows = getHittableRows(playerX).filter(it => level.features[it] === 16);
					if (ruinedObeliskRows.length > 0) {
						if (totems >= 1) {
							totems--;
							level.features[ruinedObeliskRows[0]] = 0;
							placeFeatureEntity("obelisk", ruinedObeliskRows[0], false);
						} else {
							notificate("bankrupt");
						};
					};
					let timeMachineRows = getHittableRows(playerX).filter(it => level.features[it] === 17);
					if (timeMachineRows.length > 0) {
						if (gems >= 100) {
							gems -= 100;
							timeTraveling = true;
						} else {
							notificate("bankrupt");
						};
					};
					for (let mob of level.mobs) {
						if (mob.type === "merchant" && mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 3 && playerY + 2 > mob.y) {
							if (mob.missionStarted) {
								if (mob.mission.satisfies(mob.startingValue)) {
									mob.mission.complete();
									notificate("MISSION COMPLETED: " + mob.mission.reward);
									level.mobs.splice(level.mobs.indexOf(mob));
								} else {
									notificate("mission: " + mob.mission.mission + " to get " + mob.mission.reward);
								};
							} else {
								mob.missionStarted = true;
								mob.startingValue = mob.mission.getStartingValue();
								notificate("mission: " + mob.mission.mission + " to get " + mob.mission.reward);
							};
						};
					};
				} else if (e.key === "g") {
					showScroll(
						"Mimics hath the power to mimic coins or gems. "+
						"Mimics doth spawn about every 5000 blocks and thou "+
						"canst discern if a coin be a mimic if it be offcentered "+
						"from the block. When thou dost collect the false "+
						"coin or gem, it turneth into a mimic after 2 ticks. "+
						"They be 4 blocks tall and mimic thy movements, but "+
						"they doth not move if thou dost approach them, and "+
						"they turn back into a true coin or gem after 30 ticks."
					);
				};
			};
			function globalKeyDownFunction(e) {
				if (e.key === "Escape")  {
					(obeliskShopButtonShowing || obeliskShop) ? obeliskShopButton() : shopButton();
				} else if (e.key === "/" && developerMode) {
					e.preventDefault();
					document.getElementById("hacker-console").style.display = "block";
					document.getElementById("hacker-console-text").focus();
				};
			};
			function purchaseLadder() {
				if (coins >= 10) {
					coins -= 10;
					ladders++;
				} else {
					notificate("bankrupt");
				};
			};
			function placeLadder() {
				if (ladders >= 1 && level.features[Math.floor(playerX)] === 0) {
					level.features[Math.floor(playerX)] = 3;
					ladders--;
				};
			};
			function purchaseTallLadder() {
				if (coins >= 25) {
					coins -= 25;
					tallLadders++;
				} else {
					notificate("bankrupt");
				};
			};
			function placeTallLadder() {
				if (tallLadders >= 1 && level.features[Math.floor(playerX)] === 0) {
					level.features[Math.floor(playerX)] = 4;
					tallLadders--;
				};
			};
			function brewPotion(potion) {
				if (gems >= potions[potion].cost) {
					potions[potion].howmany++;
					gems -= potions[potion].cost;
				} else {
					notificate("bankrupt");
				};
			};
			function chugPotion(potion) {
				if (potions[potion].howmany >= 1) {
					potions[potion].howmany--;
					potions[potion].time += potions[potion].duration;
				};
			};
			function codeToSave(text) {
				return JSON.parse(text);
			};
			function saveToCode(save) {
				return JSON.stringify(save);
			};
			function getSave() {
				return {
					level,
					playerX,
					playerY,
					playerXV,
					playerYV,
					coins,
					gems,
					ladders,
					tallLadders,
					health,
					dead,
					bootses,
					boots,
					foods,
					potions,
					pb,
					gameTime,
					totems,
					dybbukTime,
					basePlayerSpeed,
					baseJumpHeight,
					maxHealth,
					score,
					baseStepHeight,
					oxygen,
					trampolines,
					cameraX,
					cameraY,
					possessionTime,
					possessionDoll,
					dimension,
					portalX,
					portalTime,
					portalSkew,
					lanternTime
				};
			};
			function saveSlot(slot) {
				let saveCode = saveToCode(getSave());
				localStorage.setItem("forestSimulator3DSaveSlot" + slot, saveCode);
			};
			function loadSlot(slot) {
				let saveCode = localStorage.getItem("forestSimulator3DSaveSlot" + slot);
				if (saveCode === null) {
					notificate("save slot " + slot + " empty, to create a new save slot reload and press save in the new one you want to create");
				} else {
					saveCode = codeToSave(saveCode);
					loadSave(saveCode);	
				};
			};
			function loadSave(save) {
				level = save.level ?? level;
				playerX = save.playerX ?? playerX;
				playerY = save.playerY ?? playerY;
				playerXV = save.playerXV ?? playerXV;
				playerYV = save.playerYV ?? playerYV;
				coins = save.coins ?? coins;
				gems = save.gems ?? gems;
				ladders = save.ladders ?? ladders;
				tallLadders = save.tallLadders ?? tallLadders;
				health = save.health ?? health;
				dead = save.dead ?? dead;
				bootses = save.bootses ?? bootses;
				boots = save.boots ?? boots;
				foods = save.foods ?? foods;
				potions = save.potions ?? potions;
				pb = save.pb ?? pb;
				gameTime = save.gameTime ?? gameTime;
				totems = save.totems ?? totems;
				dybbukTime = save.dybbukTime ?? dybbukTime;
				basePlayerSpeed = save.basePlayerSpeed ?? basePlayerSpeed;
				baseJumpHeight = save.baseJumpHeight ?? baseJumpHeight;
				maxHealth = save.maxHealth ?? maxHealth;
				score = save.score ?? score;
				baseStepHeight = save.baseStepHeight ?? baseStepHeight;
				oxygen = save.oxygen ?? oxygen;
				trampolines = save.trampolines ?? trampolines;
				cameraX = save.cameraX ?? cameraX;
				cameraY = save.cameraY ?? cameraY;
				possessionTime = save.possessionTime ?? possessionTime;
				possessionDoll = save.possessionDoll ?? possessionDoll;
				dimension = save.dimension ?? dimension;
				portalX = save.portalX ?? portalX;
				portalTime = save.portalTime ?? portalTime;
				portalSkew = save.portalSkew ?? portalSkew;
				lanternTime = save.lanternTime ?? lanternTime;
			};
			function clearSlot(slot) {
				localStorage.removeItem("forestSimulator3DSaveSlot" + slot);
			};
			function clearAllSlots() {
				localStorage.clear();
			};
			function exportSave() {
				saveFile("forestSimulator3DSave.json", "application/json", saveToCode(getSave()));
			};
			function importSave() {
				let filePicker = document.createElement("input");
				filePicker.type = "file";
				filePicker.accept = "application/json";
				filePicker.onchange = e => {
					var reader = new FileReader();
					reader.onload = event => {
						try {
							loadSave(codeToSave(event.target.result));
						} catch (err) {
							notificate("malformed save code");
						};
					};
					reader.onerror = event => {
						notificate("error reading file");
					};
					reader.readAsText(e.target.files[0], "UTF-8");
				};
				filePicker.click();
			};
			function saveFile(name, mime, content) {
				var a = document.createElement("a");
				a.href = "data:" + mime + "," + content;
				a.download = name;
				a.click();
				a.remove();
			};
			function spawnMob(type, x, y) {
				let mob = {
					type: type,
					x: x,
					y: y,
					age: 0
				};
				if (type === "mimic") {
					mob.mimicTarget = ["coin", "gem"][Math.floor(mb32.rng(level.featureRNG) * 2)];
					mob.mimicTimer = false;
					mob.mimicking = true;
					mob.mimicSpawnAge = 0;
					mob.deltaX = 0;
				} else if (type === "leprechaun") {
					mob.coins = arguments[3];
				} else if (type === "possessed doll") {
					mob.possessed = false;
				} else if (type === "merchant") {
					mob.missionStarted = false;
					mob.notificated = false;
					mob.startingValue = null;
					mob.mission = missions[Math.floor(mb32.rng(level.featureRNG) * missions.length)];
				};
				level.mobs.push(mob);
			};
			function notificate(message, time=180) {
				notification = message;
				notificationTime = time;
			};
			function placeFeatureEntity(type, x) {
				let featureEntity = {
					"type": type
				};
				if (type === "obelisk") {
					featureEntity.yOffset = arguments[2] ? -4 : 0;
					featureEntity.riseSpeed = arguments[2] ? 0.005 : 0;
				} else if (type === "scaffolding") {
					featureEntity.height = arguments[2];
				} else if (type === "sentry house") {
					featureEntity.variant = arguments[2];
					featureEntity.sentries = Math.floor(mb32.rng(level.featureRNG) * 3);
				} else if (type === "mystery crate") {
					let random = arr => arr[Math.floor(mb32.rng(level.featureRNG) * arr.length)];
					let crateOption = ["food", "potion", "ladder", "coins", "gems", "nothing"];
					crateOption = crateOption[Math.floor(mb32.rng(level.featureRNG) * crateOption.length)];
					let specific = null;
					switch (crateOption) {
						case "food":
							specific = random(Object.keys(foods));
							break;
						case "potion":
							specific = random(Object.keys(potions));
							break;
						case "ladder":
							specific = ["ladder", "tall ladder"][Math.floor(mb32.rng(level.featureRNG) * 2)];
							break;
						case "coins":
							specific = Math.floor(mb32.rng(level.featureRNG) * 19 + 1);
							break;
						case "gems":
							specific = Math.floor(mb32.rng(level.featureRNG) * 3 + 1);
							break;
						case "nothing":
							if (mb32.rng(level.featureRNG) < 1 / 100) {
								specific = ["spawned 1000 sentries", []];
								for (let i = 0; i < 1000; i++) {
									specific[1].push(mb32.rng(level.featureRNG) * level.rows.length);
								};
							} else {
								specific = ["get better"];
							};
					};
					featureEntity.crateOption = crateOption;
					featureEntity.specific = specific;
				} else if (type === "burlap sack") {
					let foodsKeys = Object.keys(foods);
					featureEntity.food = foodsKeys[Math.floor(mb32.rng(level.featureRNG) * foodsKeys.length)];
				} else if (type === "four leaf clover") {
					featureEntity.coins = Math.round(mb32.rng(level.featureRNG) * 50 + 50);
				} else if (type === "pot of gold") {
					featureEntity.coins = arguments[2];
				};
				level.featureEntities[Math.floor(x)] = featureEntity;
			};
			function placeGolem(type, x, rising) {
				let golem = {
					"type": type,
					"yOffset": rising ? -golems[type].height : 0,
					"ySpeed": rising ? golems[type].riseSpeed : 0
				};
				level.golems[Math.floor(x)] = golem;
			};
			function obeliskShopUpgradeButton(item) {
				if (totems >= 1) {
					switch (item) {
						case "health":
							if (maxHealth < 2) {
								maxHealth = Math.min(maxHealth + 0.1, 2);
							} else {
								notificate("upgrade maxed");
							};
							break;
						case "speed":
							if (basePlayerSpeed < 0.35) {
								basePlayerSpeed = Math.min(basePlayerSpeed + 0.02, 0.35);
							} else {
								notificate("upgrade maxed");
							};
							break;
						case "jump":
							if (baseJumpHeight < 0.5) {
								baseJumpHeight = Math.min(baseJumpHeight + 0.03, 0.5);
							} else {
								notificate("upgrade maxed");
							};
							break;
						case "step":
							if (baseStepHeight < 1.1) {
								baseStepHeight = Math.min(baseStepHeight + 0.1, 1.1);
							} else {
								notificate("upgrade maxed");
							};
					};
					totems--;
				} else {
					notificate("bankrupt");
				};
			};
			function purchaseScaffolding() {
				let height = Math.round(parseInt(prompt("what height (1 coin/block)")));
				if (height > 0) {
					if (coins >= height) {
						placeFeatureEntity("scaffolding", playerX, height);
						coins -= height;
					} else {
						notificate("bankrupt");
					};
				};
			};
			function playButton() {
				document.getElementById("menu").style.display = "none";
				document.getElementById("canvas-wrapper").focus();
				document.getElementById("cursor").style.display = "none";
				let seed = document.getElementById("seed").value;
				if (seed.length > 0) {
					if (document.getElementById("seed-as-number-checkbox").checked && !Number.isNaN(parseFloat(seed))) {
						seed = parseFloat(seed);
					};
				} else {
					seed = Math.floor(Math.random() * 0x80000000);
				};
				level.featureRNG = mb32.new(seed);
				level.levelRNG = mb32.new(seed);
				generateOctaves();
				playerY = getRowY(level.rows, 0);
				playing = true;
			};
			function purchaseTrampoline() {
				if (coins >= 45) {
					coins -= 45;
					trampolines++;
				} else {
					notificate("bankrupt");
				};
			};
			function placeTrampoline() {
				if (trampolines >= 1 && level.features[Math.floor(playerX)] === 0) {
					level.features[Math.floor(playerX)] = 18;
					trampolines--;
				};
			};
			function range(start, end) {
				var array = [];
				if (end - start > 25000000) {
					console.error("range too large (" + (end - start) + ")");
					return array;
				};
				for (let i = 0; i <= end - start; i++) {
					array.push(start + i);
				};
				return array;
			};
			function getRowY(rows, x) {
				x = Math.floor(x);
				if (x <= -5 && x > -25) {
					return -2000000;
				};
				return (x >= 0 && x < rows.length) ? rows[x] : Math.round(getPerlinHeight(x));
			};
			function saveSlotSelectorButton() {
				saveSlotNumber = (saveSlotNumber + 1) % 3;
				document.getElementById("save-slot-selector").innerHTML = "slot " + saveSlotNumber + " (click to change)";
			};
			function getDarkness(time) {
				return Math.max(Math.sin((time - 300) / (300 / Math.PI)), 0) ** 2;
			};
			function getBakedRows() {
				let bakedRows = [...level.rows];
				for (let i = 0; i < bakedRows.length; i++) {
					bakedRows[i] += (level.features[i] === 5) * 5;
					if (level.golems[i] && level.golems[i].type === "golem") {
						let height = level.golems[i].yOffset + 3;
						bakedRows[i] = level.rows[i] + height;
					} else if (level.golems[i] && level.golems[i].type === "russet golem") {
						let height = level.golems[i].yOffset + 6;
						bakedRows[i] = level.rows[i]+ height;
					} else if (level.golems[i] && level.golems[i].type === "aqua golem") {
						let height = level.golems[i].yOffset + 9;
						bakedRows[i] = level.rows[i] + height;
					} else if (level.golems[i] && level.golems[i].type === "mecha golem") {
						let height = level.golems[i].yOffset + 12;
						bakedRows[i - 1] = level.rows[i] + height;
						bakedRows[i] = level.rows[i] + height;
						bakedRows[i + 1] = level.rows[i] + height;
					} else if (level.golems[i] && level.golems[i].type === "celestial golem") {
						let height = level.golems[i].yOffset + 100;
						bakedRows[i] = level.rows[i] + height;
					} else if (level.features[i] === 18) {
						bakedRows[i] = level.rows[i] + 1;
					};
				};
				return bakedRows;
			};
			function clockEmoji(time=gameTime) {
				var clocks = ["üïõ", "üïß", "üïê", "üïú", "üïë", "üïù", "üïí", "üïû", "üïì", "üïü", "üïî", "üï†", "üïï", "üï°", "üïñ", "üï¢", "üïó", "üï£", "üïò", "üï§", "üïô", "üï•", "üïö", "üï¶"];
				return clocks[Math.floor(Math.mod((time - 150), 300) / 12.5)];
			};
			function rectIntersection(p1, p2, b1, b2) {
				var t = 0;
				if ((p1.x >= b1.x && p1.x <= b2.x && p1.y >= b1.y && p1.y <= b2.y) || (p2.x >= b1.x && p2.x <= b2.x && p2.y >= b1.y && p2.y <= b2.y)) {
					return true;
				};
				if (p1.x < b1.x && p2.x >= b1.x) { // Left edge
					t = p1.y + (p2.y - p1.y) * (b1.x - p1.x) / (p2.x - p1.x);
					if (t > b1.y && t <= b2.y) {
						return true;
					};
				} else if (p1.x > b2.x && p2.x <= b2.x) { // Right edge
					t = p1.y + (p2.y - p1.y) * (b2.x - p1.x) / (p2.x - p1.x);
					if (t >= b1.y && t <= b2.y) {
						return true;
					};
				};
				if (p1.y < b1.y && p2.y >= b1.y) { // Top edge
					t = p1.x + (p2.x - p1.x) * (b1.y - p1.y) / (p2.y - p1.y);
					if (t >= b1.x && t <= b2.x) {
						return true;
					};
				} else if (p1.y > b2.y && p2.y <= b2.y) {	// Bottom edge
					t = p1.x + (p2.x - p1.x) * (b2.y - p1.y) / (p2.y - p1.y);
					if (t >= b1.x && t <= b2.x) {
						return true;
					};
				};
				return false;
			};
			function lineIntersection(p1, p2, p3, p4) {
				var det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
				if (det === 0) {
					return false;
				} else {
					let lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
					let gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;
					return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
				};
			};
			function openPortal() {
				portalX = playerX + 3;
				portalTime = 60 * 60;
				let skewiness = 2;
				portalSkew = Math.random() * skewiness - skewiness / 2;
			};
			function getURLParam(param) {
				return new URLSearchParams(location.search).get(param);
			};
			function distance(p1, p2) {
				return Math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2);
			};
			function hackerConsoleKeyDown(e) {
				if (e.key === "Enter") {
					try {
						let args = e.target.value.split(" ").map(it => /^[-+]?[0-9]+\.?([0-9]+)?$/g.test(it) ? parseFloat(it) : it);
						switch (args[0]) {
							case "spawn":
								let mobX = playerX + (args[2] ?? 0);
								spawnMob(args[1], mobX, getRowY(level.rows, mobX));
								break;
							case "place":
								switch (args[1]) {
									case "feature":
										level.features[Math.floor(playerX + (args[3] ?? 0))] = (args[2] ?? 0);
								};
								break;
							case "tp":
								playerX = args[1] ?? playerX;
								playerY = args[2] ?? playerY;
								break;
							case "heal":
								health = maxHealth;
								dead = health <= 0;
								oxygen = 1;
								break;
							case "reset":
								playerXV = 0;
								playerYV = 0;
								playerX = 0.5;
								playerY = getRowY(level.rows, 0) ?? 0;
								cameraSnapPending = true;
								gameTime = 0;
								health = maxHealth;
								dead = health <= 0;
								oxygen = 1;
								break;
							case "obeliskshop":
								obeliskShopButton();
								break;
							case "setspeed":
								basePlayerSpeed = args[1] ?? 0.2;
								break;
							case "setjump":
								jumpHeight = args[1] ?? 0.24;
								break;
							case "setstep":
								baseStepHeight = args[1] ?? 0.5;
								break;
							case "give":
								switch (args[1]) {
									case "coin":
										coins += args[2] ?? 1;
										break;
									case "gem":
										gems += args[2] ?? 1;
										break;
									case "totem":
										totems += args[2] ?? 1;
										break;
									case "ladder":
										ladders += args[2] ?? 1;
										break;
									case "tallladder":
										tallLadders += args[2] ?? 1;
										break;
									case "trampoline":
										trampolines += args[2] ?? 1;
								};
						};
					} catch (e) {
						notificate("command error");
					};
					e.target.value = "";
					document.getElementById("hacker-console").style.display = "none";
					document.getElementById("canvas-wrapper").focus();
				};
			};
			function purchaseLantern() {
				if (coins >= 10) {
					lanternTime += 3600;
					coins -= 10;
				} else {
					notificate("bankrupt");
				};
			};
			function bigIntString(number) {
				if (Number.isNaN(number)) {
					return "NaN";
				};
				if (number === Infinity) {
					return "Infinity";
				};
				if (number === -Infinity) {
					return "-Infinity";
				};
				return BigInt(number).toString();
			};
			function showScroll(text) {
				document.querySelector("#scroll-container .scroll div").innerText = text;
				document.querySelector("#scroll-container").style.display = "flex";
				scrollShowing = true;
			};
			function hideScroll() {
				document.querySelector("#scroll-container .scroll div").innerText = "";
				document.querySelector("#scroll-container").style.display = "none";
				scrollShowing = false;
			};

			var seedUrlParam = getURLParam("seed");
			if (seedUrlParam !== undefined) {
				document.getElementById("seed").value = seedUrlParam;
				document.getElementById("seed-as-number-checkbox").checked = (getURLParam("asNumber") === "true");
			};
	
			function tick() {
				document.getElementById("joystick").style.display = document.getElementById("joystick-checkbox").checked ? "flex" : "none";
				let magnitudes = {
					"keyboard": {
						"up": (isDown("ArrowUp") || isDown("w")) * 1,
						"down": (isDown("ArrowDown") || isDown("s")) * 1,
						"left": (isDown("ArrowLeft") || isDown("a")) * 1,
						"right": (isDown("ArrowRight") || isDown("d")) * 1
					},
					"joystick": {
						"up": Math.max(joystick.getAmplitudes().y, 0),
						"down": Math.max(-joystick.getAmplitudes().y, 0),
						"left": Math.max(-joystick.getAmplitudes().x, 0),
						"right": Math.max(joystick.getAmplitudes().x, 0)
					},
					"gamepad": {
						"up": 0,
						"down": 0,
						"left": 0,
						"right": 0
					},
					"possession": {
						"up": Math.random() * (possessionTime > 0),
						"down": Math.random() * (possessionTime > 0),
						"left": Math.random() * (possessionTime > 0),
						"right": Math.random() * (possessionTime > 0)
					}
				};
				cameraPanX = 0;
				cameraPanY = 0;
				if (navigator.getGamepads().filter(it => it !== null).length > 0) {
					let gamePad = navigator.getGamepads()[0];
					magnitudes.gamepad.up =		Math.min(Math.max(-gamePad.axes[1], 0) + gamePad.buttons[0].value + gamePad.buttons[12].value, 1);
					magnitudes.gamepad.down =	Math.min(Math.max(gamePad.axes[1], 0) + gamePad.buttons[13].value, 1);
					magnitudes.gamepad.left =	Math.min(Math.max(-gamePad.axes[0], 0) + gamePad.buttons[14].value, 1);
					magnitudes.gamepad.right =	Math.min(Math.max(gamePad.axes[0], 0) + gamePad.buttons[15].value, 1);
					cameraPanX = gamePad.axes[2] * 10;
					cameraPanY = -gamePad.axes[3] * 10;
					if (gamePad.buttons[9].pressed && !oldGamePadMenuButtonPressed) {
						(obeliskShopButtonShowing || obeliskShop) ? obeliskShopButton() : shopButton();
					};
					if (shop || obeliskShop || !playing) {
						cursorX += gamePad.axes[0] * 3;
						cursorY += gamePad.axes[1] * 3;
						if (gamePad.buttons[0].pressed && !oldGamePadAButtonPressed) {
							document.elementFromPoint(cursorX, cursorY).click();
						};
						if (shop) {
							document.getElementById("shop").scrollBy(0, gamePad.axes[3] * 5);
						};
					};
					oldGamePadMenuButtonPressed = gamePad.buttons[9].pressed;
					oldGamePadAButtonPressed = gamePad.buttons[0].pressed;
				}
				controls.up = clamp((magnitudes.keyboard.up + magnitudes.joystick.up + magnitudes.gamepad.up) * (possessionTime <= 0) + magnitudes.possession.up, 0, 1);
				controls.down = clamp((magnitudes.keyboard.down + magnitudes.joystick.down + magnitudes.gamepad.down) * (possessionTime <= 0) + magnitudes.possession.down, 0, 1);
				controls.left = clamp((magnitudes.keyboard.left + magnitudes.joystick.left + magnitudes.gamepad.left) * (possessionTime <= 0) + magnitudes.possession.left, 0, 1);
				controls.right = clamp((magnitudes.keyboard.right + magnitudes.joystick.right + magnitudes.gamepad.right) * (possessionTime <= 0) + magnitudes.possession.right, 0, 1);
				document.getElementById("cursor").style.left = cursorX - 15 + "px";
				document.getElementById("cursor").style.top = cursorY - 15 + "px";
				if (!shop && !dead && !obeliskShop && playing) {
					if (playerX >= level.rows.length) {
						generateLevel();
					};
	
					let bakedRows = getBakedRows();
	
					gameTime += 1 / 60;
					possessionTime = Math.max(possessionTime - 1 / 60, 0);
					portalTime = Math.max(portalTime - 1, 0);
	
					for (let potion in potions) {
						potions[potion].time = Math.max(potions[potion].time - (1 / 60), 0);
					};
					flying = potions["bird potion"].time > 0;
					inWater = playerY < bakedRows[Math.floor(playerX)] + level.waterLevel[Math.floor(playerX)] && level.waterLevel[Math.floor(playerX)] > 0.75;
	
					let oldPlayerX = playerX;
					let oldPlayerY = playerY;
					// X MOVEMENT //
					
					let playerSpeed = basePlayerSpeed + (boots === "running shoes") * 0.04 + (potions["speed potion"].time > 0) * 0.1;
					let groundFriction = (boots === "spike boots") ? 0.9 : layers[getLayer(playerY)][1];
	
					let sign = controls.right - controls.left;
					let maxXV = (inLadder ? sign * (boots === "magnet boots" ? 0 : inLadderSpeed) : (flying ? (sign * basePlayerSpeed * 1.5) : (sign * playerSpeed)));
					playerXV = lerp(lerp(maxXV, playerXV, onGround ? 1 - groundFriction : 0.15) + (sign * 0.04 * (controls.up > 0.5 && onGround && !inWater)), playerXV * (inLadder ? 0 : (onGround ? 1 - groundFriction : 0.99)), 1 - Math.abs(sign));
	
					if (inWater) {
						playerXV *= 0.9;
						playerXV = clamp(playerXV, -0.3, 0.3);
					};
					let hittableRows = getHittableRows(playerX + playerXV);
					let max = hittableRows.reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b);
					if ((hittableRows[0] !== undefined && getRowY(bakedRows, hittableRows[0]) > playerY) || (hittableRows[1] !== undefined && getRowY(bakedRows, hittableRows[1]) > playerY)) {
						if (onGround && playerY >= getRowY(bakedRows, max) - ((boots === "stepping boots") ? baseStepHeight * 2 : baseStepHeight) && potions["spider potion"].time <= 0) {
							playerY = getRowY(bakedRows, max);
						} else {
							playerXV = Math.ceil(playerX + (playerXV / 2)) - 0.5 - playerX;
							if (potions["spider potion"].time > 0) {
								playerYV = 0;
								playerY += 0.2;
							};
						};
					};
					hittableRows = getHittableRows(playerX + playerXV);
					max = hittableRows.reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b);
					let trampoline = level.features[max] === 18 && playerY + playerYV <= getRowY(bakedRows, max);
					if (trampoline) {
						playerXV *= 0.2;
					};
					playerX += playerXV;
					
					// Y MOVEMENT //
	
					if (inLadder) {
						playerYV = (controls.up - controls.down) * (boots === "magnet boots" ? 0 : inLadderSpeed);
					} else if (flying) {
						if (controls.up !== controls.down) {
							playerYV = (controls.up - controls.down) * basePlayerSpeed * 1.5;
						};
						playerYV *= 0.99;
					} else if (!trampoline) {
						let jumpHeight = baseJumpHeight + (boots === "spring boots") * 0.06 + (potions["jumping potion"].time > 0) * 0.08;
						playerYV += (controls.up > 0.5) * onGround * !inWater * (jumpHeight + Math.abs(playerXV) * 0.15);
					};
	
					//gravity
					let layer = getLayer(playerY);
					let gravity = layers[layer][2];
					if (layer === 0 && boots === "magnet boots") {
						gravity -= 0.012;
					};
					if (inWater) {
						gravity = -0.001;
						if (controls.up === controls.down) {
							gravity = -0.001;
						} else {
							if (controls.up > 0.5) {
								gravity = 0.01;
							} else if (controls.down > 0.5) {
								gravity = -0.01;
							};
						};
					};
					playerYV = potions["levitation potion"].time > 0 ? 0.1 : (playerYV + ((inLadder || flying) ? 0 : gravity * ((potions["anti gravity potion"].time > 0) ? 0.5 : 1)));
	
					if (boots === "feather boots") {
						playerYV = Math.max(playerYV, -0.3);
					};
					if (inWater) {
						playerYV *= 0.98;
						playerYV = clamp(playerYV, -0.3, 0.3);
					};
					hittableRows = getHittableRows(playerX);
					max = hittableRows.reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b);
					let oldOnGround = onGround;
					onGround = playerY + playerYV <= getRowY(bakedRows, max);
					if (!oldOnGround && onGround && playerYV <= -0.6) {
						health -= playerYV * -0.05;
					};
					trampoline = level.features[max] === 18 && onGround;
					if (onGround && !trampoline) {
						if (getLayer(level.rows[max]) === 9 && level.rows[max] - 900 > (level.originalRows[max] - 900) * 0.9 && boots !== "tennis rackets") {
							let howmany = 0;
							let left = getLayer(getRowY(level.rows, max - 1)) == 9;
							let right = getLayer(getRowY(level.rows, max + 1)) == 9;
							if (left) {
								howmany += 0.0025;
								level.rows[max - 1] += 0.0025;
							};
							if (right) {
								howmany += 0.0025;
								level.rows[max + 1] += 0.0025;
							};
							level.rows[max] -= howmany;
							//if (level.rows[max] - 200 < (level.originalRows[max] - 200) * 0.9) {
							//	level.rows[max] = (level.originalRows[max] - 200) * 0.9 + 200;
							//};
						};
						playerY = getRowY(bakedRows, max);
						playerYV = 0;
					} else if (trampoline) {
						playerY = level.rows[max] + 1;
						playerYV *= -1;
					};
					playerY += playerYV;
	
					let portalSize = clamp(portalTime / 120, 0, 1);
					let portalOffset = [portalSize * portalSkew / 2.0, portalSize * 5.0 / 2.0];
					let portalY = getRowY(level.rows, portalX);
					if (portalTime > 0 && lineIntersection(
						{x: oldPlayerX, y: oldPlayerY + 1},
						{x: playerX, y: playerY + 1},
						{x: portalX - portalOffset[0], y: portalY + 2.5 - portalOffset[1]},
						{x: portalX + portalOffset[0], y: portalY + 2.5 + portalOffset[1]})) {
						dimension = (dimension === "normal") ? "upside down" : "normal";
					};
					// ROW LOOP //
	
					let oldInLadder = inLadder;
					inLadder = false;
					dybbukTime = Math.max(0, dybbukTime - 1);
					lanternTime = Math.max(0, lanternTime - 1);
					document.getElementById("obelisk-shop-button").style.display = "none";
					obeliskShopButtonShowing = false;
					// water
					let totalWaterHeight = x => level.waterLevel[x] + bakedRows[x];
					let waterTick = function(x) {
						let waterLeft = bakedRows[x - 1] < totalWaterHeight(x);
						let waterRight = bakedRows[x + 1] < totalWaterHeight(x);
						let averageHeight = (totalWaterHeight(x - 1) * waterLeft + totalWaterHeight(x) + totalWaterHeight(x + 1) * waterRight) / (1 + waterLeft + waterRight);
						if (waterLeft) level.waterLevel[x - 1] = averageHeight - bakedRows[x - 1];
						level.waterLevel[x] = averageHeight - bakedRows[x];
						if (waterRight) level.waterLevel[x + 1] = averageHeight - bakedRows[x + 1];
					};
					for (let j = 0; j < 3; j++) {
						for (let i = 0; i < level.rows.length; i++) {
							if (i >= 1 && i < bakedRows.length - 1 && level.waterLevel[i] > 0) {
								waterTick(i);
							};
						};
						for (let i = level.rows.length - 1; i <= 0; i--) {
							if (i >= 1 && i < bakedRows.length - 1 && level.waterLevel[i] > 0) {
								waterTick(i);
							};
						};
					};
					for (let i = 0; i < level.rows.length; i++) {
						// features
						if (playerX + 0.5 > i && playerX - 0.5 < i + 1) {
							if (playerY < level.rows[i] + 1) {
								switch (level.features[i]) {
									case 2:
										if (dybbukTime <= 0) {
											gems += (dimension === "upside down") ? 2 : 1;
										};
										level.features[i] = 0;
										break;
									case 10:
										dybbukTime = 1200;
										level.features[i] = 11;
										break;
									case 12:
										if (dybbukTime <= 0) {
											totems += (dimension === "upside down") ? 2 : 1;
										};
										level.features[i] = 0;
										break;
								};
							};
							if (level.features[i] === 1 && (boots === "magnet boots" || playerY < level.rows[i] + 1)) {
								if (dybbukTime <= 0) {
									coins += (dimension === "upside down") ? 2 : 1;
								};
								level.features[i] = 0;
							};
							if ((playerY < level.rows[i] + 4 && level.features[i] === 3) || (playerY < bakedRows[i] + 6 && level.features[i] === 4)) {
								inLadder = true;
								inLadderSpeed = 0.1;
							};
							if (level.featureEntities[i] && playerY < bakedRows[i] + level.featureEntities[i].height) {
								inLadder = true;
								inLadderSpeed = 0.02 / level.featureEntities[i].height;
							};
							if (inLadder && !oldInLadder) {
								playerXV = 0;
								playerYV = 0;
							};
							if (playerY < level.rows[i] + 3 && level.features[i] === 7) {
								if (dybbukTime <= 0) {
									spawnMob("sentry", i + 0.5, bakedRows[i + 1]);
								};
								level.features[i] = 8;
							};
							if (onGround && playerY === level.rows[i] && boots !== "tennis rackets" && level.features[i] === 9) {
								level.rows[i - 1] = level.rows[i] = level.rows[i + 1] = level.rows[i] - 4;
								level.features[i - 1] = 0;
								level.features[i] = 0;
								level.features[i + 1] = 0;
								onGround = false;
							};
							if (playerY < level.rows[i] + 4 && level.features[i] === 16) {
								notificate("press e to repair obelisk (1 totem)");
							};
							if (playerY < level.rows[i] + 2 && level.features[i] === 17) {
								notificate("press e to time travel (100 gems)");
							};
						};
						if (Math.floor(gameTime * 60) % Math.round(sounds.humanoidAmbient.element.duration * 60) === 0 && level.features[i] === 19) {
							soundSystem.emitSound(sounds.humanoidAmbient, [i + 0.5, getRowY(level.rows, i) + 2]);
						};
						// feature entities
						if (level.featureEntities[i]) {
							switch (level.featureEntities[i].type) {
								case "obelisk":
									level.featureEntities[i].yOffset += level.featureEntities[i].riseSpeed;
									if (level.featureEntities[i].yOffset > 0) {
										level.featureEntities[i].riseSpeed = 0;
										level.featureEntities[i].yOffset = 0;
									} else if (level.featureEntities[i].yOffset <= -4) {
										level.featureEntities[i] = null;
										continue;
									};
									if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY < level.rows[i] + 4 && level.featureEntities[i].riseSpeed === 0) {
										document.getElementById("obelisk-shop-button").style.display = "block";
										obeliskShopButtonShowing = true;
									};
									break;
								case "sentry house":
									if (playerX + 0.5 > i - 0.5 && playerX - 0.5 < i + 1.5 && playerY < level.rows[i] + 3 && level.featureEntities[i].sentries > 0) {
										spawnMob("sentry", i + 0.5, level.rows[i]);
										level.featureEntities[i].sentries--;
									};
									level.featureEntities[i];
									break;
								case "mystery crate":
									if ((playerX + 0.5 > i && playerX - 0.5 < i + 1 && (playerY < level.rows[i] + 1 || (boots === "magnet boots" && (level.featureEntities[i].crateOption === "coins" || level.featureEntities[i].crateOption === "ladder"))))) {
										if (dybbukTime <= 0) {
											let crateOption = level.featureEntities[i].crateOption;
											let specific = level.featureEntities[i].specific;
											switch (crateOption) {
												case "food":
													foods[specific].howmany++;
													break;
												case "potion":
													potions[specific].howmany++;
													break;
												case "ladder":
													switch (specific) {
														case "ladder":
															ladders++;
															break;
														case "tall ladder":
															tallLadders++;
													};
													break;
												case "coins":
													coins += specific;
													break;
												case "gems":
													gems += specific;
													break;
												case "nothing":
													if (specific[0] === "spawned 1000 sentries") {
														for (let i = 0; i < specific[1].length; i++) {
															spawnMob("sentry", specific[1][i], 0);
														};
													};
											};
											notificate("mystery crate opened! item: " + crateOption + " (" + specific + ")");
										};
										level.featureEntities[i] = null;
									};
									break;
								case "burlap sack":
									if (playerX + 0.5 > i && playerX - 0.5 < i + 1 && playerY < level.rows[i] + 1) {
										if (dybbukTime <= 0) {
											foods[level.featureEntities[i].food].howmany++;
											notificate("burlap sack contains " + level.featureEntities[i].food);
										};
										level.featureEntities[i] = null;
									};
									break;
								case "four leaf clover":
									if (playerX + 0.5 > i && playerX - 0.5 < i + 1 && playerY < level.rows[i] + 1) {
										spawnMob("leprechaun", i + 2.5, bakedRows[i], level.featureEntities[i].coins);
										level.featureEntities[i] = null;
									};
									break;
								case "pot of gold":
									if (playerX + 0.5 > i && playerX - 0.5 < i + 1 && (playerY < level.rows[i] + 1 || boots === "magnet boots")) {
										coins += level.featureEntities[i].coins;
										notificate("pot of gold contains " + level.featureEntities[i].coins + " coins");
										level.featureEntities[i] = null;
									};
									break;
							};
						};
						if (level.golems[i]) {
							let spawnOffset;
							let golemType = level.golems[i].type;
							/*switch (level.golems[i].type) {
								case "golem":*/
									spawnOffset = 35;
									if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + golems[golemType].height && onGround && level.golems[i].ySpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
										level.golems[i].ySpeed = golems[golemType].sinkSpeed;
										placeGolem("golem", i + spawnOffset, true);
									};
									level.golems[i].yOffset += level.golems[i].ySpeed;
									if (level.golems[i].yOffset > 0) {
										level.golems[i].ySpeed = 0;
										level.golems[i].yOffset = 0;
									} else if (level.golems[i].yOffset <= -golems[golemType].height) {
										level.golems[i] = null;
										continue;
									};/*
									break;
								case "russet golem":
									spawnOffset = 100;
									if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + 6 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
										level.golems[i].riseSpeed = -0.01;
										placeFeatureEntity("russet golem", i + spawnOffset, true);
										if (level.golems[i + Math.floor(spawnOffset / 2)] === null)	{
											placeFeatureEntity("golem", i + Math.floor(spawnOffset / 2), true);
										};
									};
									level.golems[i].yOffset += level.golems[i].riseSpeed;
									if (level.golems[i].yOffset > 0) {
										level.golems[i].riseSpeed = 0;
										level.golems[i].yOffset = 0;
									} else if (level.golems[i].yOffset <= -6) {
										level.golems[i] = null;
										continue;
									};
									break;
								case "aqua golem":
									spawnOffset = 10;
									if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + 9 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
										level.golems[i].riseSpeed = -0.005;
										placeFeatureEntity("aqua golem", i + spawnOffset, true);
										if (level.golems[i + Math.floor(spawnOffset * (1 / 3))] === null)	{
											placeFeatureEntity("russet golem", i + Math.floor(spawnOffset * (1 / 3)), true);
										};
										if (level.golems[i + Math.floor(spawnOffset * (2 / 3))] === null)	{
											placeFeatureEntity("golem", i + Math.floor(spawnOffset * (2 / 3)), true);
										};
									};
									level.golems[i].yOffset += level.golems[i].riseSpeed;
									if (level.golems[i].yOffset > 0) {
										level.golems[i].riseSpeed = 0;
										level.golems[i].yOffset = 0;
									} else if (level.golems[i].yOffset <= -9) {
										level.golems[i] = null;
										continue;
									};
									break;
								case "mecha golem":
									spawnOffset = 10;
									if (i + 2 > playerX - 0.5 && i - 1 < playerX + 0.5 && playerY <= level.rows[i] + 12 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
										level.golems[i].riseSpeed = -0.01;
										placeFeatureEntity("mecha golem", i + spawnOffset, true);
										if (level.golems[i + Math.floor(spawnOffset * (1 / 4))] === null)	{
											placeFeatureEntity("aqua golem", i + Math.floor(spawnOffset * (1 / 4)), true);
										};
										if (level.golems[i + Math.floor(spawnOffset * (2 / 4))] === null)	{
											placeFeatureEntity("russet golem", i + Math.floor(spawnOffset * (2 / 4)), true);
										};
										if (level.golems[i + Math.floor(spawnOffset * (3 / 4))] === null)	{
											placeFeatureEntity("golem", i + Math.floor(spawnOffset * (3 / 4)), true);
										};
									};
									level.golems[i].yOffset += level.golems[i].riseSpeed;
									if (level.golems[i].yOffset > 0) {
										level.golems[i].riseSpeed = 0;
										level.golems[i].yOffset = 0;
									} else if (level.golems[i].yOffset <= -12) {
										level.golems[i] = null;
										continue;
									};
									break;
							};*/
						};
					};
	
					for (let mob of level.mobs) {
						switch (mob.type) {
							case "sentry":
								if (mob.age >= 120) {
									let xSign = potions["invisibility potion"].time > 0 ? 0 : Math.sign(playerX - mob.x);
									mob.x += xSign * 0.06;
									if (xSign !== Math.sign(playerX - mob.x) && potions["invisibility potion"].time <= 0) {
										mob.x = playerX;
									};
									let sentryStepHeight = getRowY(bakedRows, getHittableRows(mob.x).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b));
									if (sentryStepHeight - mob.y <= 3 || getHittableRows(mob.x).some(it => level.features[it] === 3 || level.features[it] === 4 || (level.featureEntities[it] && level.featureEntities[it].type === "scaffolding" && level.featureEntities[it].height >= getRowY(bakedRows, it + 1) - getRowY(bakedRows, it)))) {
										mob.y = sentryStepHeight;
									} else {
										mob.x = Math.ceil(mob.x) - 0.5;
									};
									if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 4 && playerY + 2 > mob.y) {
										health -= 0.01;
									};
									if (mob.age % Math.round(sounds.sentryAmbient.element.duration * 60) === 0) {
										soundSystem.emitSound(sounds.sentryAmbient, [mob.x, mob.y + 2]);
									};
									if (mob.age % Math.round(sounds.sentryIdle.element.duration * 2 * 60) === 0) {
										soundSystem.emitSound(sounds.sentryIdle, [mob.x, mob.y + 2]);
									};
									for (let collisionMob of level.mobs) {
										if (mob.x + 0.5 > collisionMob.x - 0.5 && mob.x - 0.5 < collisionMob.x + 0.5 && collisionMob.y < mob.y + 4 && collisionMob.y + 4 > mob.y && collisionMob.type === "mimic" && !collisionMob.mimicking) {
											placeFeatureEntity("obelisk", Math.floor((mob.x + collisionMob.x) / 2), true);
											level.mobs.splice(level.mobs.indexOf(mob));
											level.mobs.splice(level.mobs.indexOf(collisionMob));
										};
									};
								};
								break;
							case "mimic":
								if (!mob.mimicking) {
									let oldMobX = mob.x;
									mob.x = (mob.x > playerX ? Math.min : Math.max)(mob.x, mob.x + playerXV);
									mob.deltaX = Math.round((mob.x - oldMobX) * 1000) / 1000;
									mob.y = getRowY(bakedRows, getHittableRows(mob.x).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b));
									if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 4 && playerY + 2 > mob.y) {
										health -= (Math.sin(gameTime * 20) + 0.1) * 0.03; // 0.01
									};
								} else if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 1 && playerY + 2 > mob.y && dybbukTime <= 0) {
									mob.mimicTimer = true;
								};
								if (mob.mimicTimer) {
									mob.mimicSpawnAge++;
									mob.mimicking = (mob.mimicSpawnAge < 120);
								};
								if (mob.mimicSpawnAge - 120 >= 1800) {
									if (level.features[Math.floor(mob.x)] === 0) {
										level.features[Math.floor(mob.x)] = {"coin": 1, "gem": 2}[mob.mimicTarget];
									};
									level.mobs.splice(level.mobs.indexOf(mob), 1);
								};
								break;
							case "leprechaun":
								mob.x += 0.15//(playerX - 1.5) / (gameTime * 60);
								mob.y = getRowY(bakedRows, getHittableRows(mob.x).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b));
								if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 1.5 && playerY + 2 > mob.y) {
									let rainbowSize = 100;
									level.terrainFeatures[Math.floor(mob.x - rainbowSize)] = "rainbow";
									placeFeatureEntity("pot of gold", Math.floor(mob.x - rainbowSize), mob.coins);
									level.mobs.splice(level.mobs.indexOf(mob));
								};
								break;
							case "possessed doll":
								mob.possessed = (possessionDoll !== mob) && (gameTime % 600 >= 450 && gameTime % 600 < 550);
								if (!mob.possessed && possessionTime <= 0 && possessionDoll === mob) {
									mob.possessed = true;
									possessionDoll = null;
								};
								if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 1.5 && playerY + 2 > mob.y) {
									if (mob.possessed) {
										possessionTime = 15;
										possessionDoll = mob;
									} else {
										notificate("<span style=\"opacity: 10%;\">WHEN THE CLOCK STRIKES TWELVE</span>");
									};
								};
								if (mob.possessed) {
									if (potions["invisibility potion"].time <= 0) mob.x += Math.abs(playerXV * (0.05 / 0.2)) * (health / maxHealth) * Math.sign(playerX - mob.x);
									mob.y = getRowY(bakedRows, getHittableRows(mob.x).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b));
								};
								break;
							case "merchant":
								if (mob.missionStarted && Math.abs(mob.x - playerX) > 4) {
									let xSign = potions["invisibility potion"].time > 0 ? 0 : Math.sign(playerX - mob.x);
									mob.x += xSign * 0.16;
								};
								mob.y = getRowY(bakedRows, getHittableRows(mob.x).reduce((a, b) => getRowY(bakedRows, a) > getRowY(bakedRows, b) ? a : b));
								if (!mob.notificated) {
									notificate("press e to interact with merchant");
									mob.notificated = true;
								};
								break;
						};
						mob.age++;
					};
	
					let targetCameraX = playerX - innerWidth / blockSize / 2 + cameraPanX;
					let targetCameraY = playerY + 1 + innerHeight / blockSize / 2 + cameraPanY;
					cameraX = cameraSnapPending ? targetCameraX : lerp(cameraX, targetCameraX, 0.25);
					cameraY = cameraSnapPending ? targetCameraY : lerp(cameraY, targetCameraY, 0.25);
					cameraSnapPending = false;
	
					score = Math.max(score, Math.floor(playerX));
					pb = Math.max(pb, score);
	
					health -= (dimension === "upside down") ? 0.00016 : 0.00008;
					health += potions["regeneration potion"].time > 0 ? 0.00088 : 0;
					if (oxygen <= 0) {
						health -= 0.003;
					};
					health = clamp(health, 0, maxHealth);
					if (playerY + 1.5 < bakedRows[Math.floor(playerX)] + level.waterLevel[Math.floor(playerX)] && !divingSuit) {
						oxygen -= 0.005;
					} else {
						oxygen += 0.005;
					};
					oxygen = clamp(oxygen, 0, 1);
					dead = health <= 0;
					if (dead) {
						soundSystem.emitSound(sounds.death, [playerX, playerY + 1]);
					};
				};
				notificationTime = Math.max(0, notificationTime - 1);

				// sounds
				soundSystem.tickAllSounds();
			};
			function renderScreen() {
				document.documentElement.style.setProperty("--block-size", blockSize + "px");
				canvas.width = innerWidth;
				canvas.height = innerHeight;
				renderer.gl.viewport(0, 0, canvas.width, canvas.height);
				renderer.draw();
				anaglyphMode = 0;

				anaglyphMode = 1;
				cameraX += 0.5;
				canvas2.width = innerWidth;
				canvas2.height = innerHeight;
				renderer2.gl.viewport(0, 0, canvas2.width, canvas2.height);
				renderer2.draw();
				anaglyphMode = 2;
				cameraX -= 0.5;
			};
			function drawScreen() {
				if ((!shop && !obeliskShop && playing) || canvas.width !== innerWidth || canvas.height !== innerHeight) {
					renderScreen();
				};
				
				document.getElementById("death-screen").style.display = dead ? "flex" : "none";
				let healthPercent = health / maxHealth
				let healthR = clamp(2 - healthPercent * 2, 0, 1) * 255;
				let healthG = clamp(healthPercent * 2, 0, 1) * 255;
				let healthB = (potions["regeneration potion"].time > 0) * 127;
				document.getElementById("health").style.width = "min(calc(40% * " + (maxHealth / 1) + "), calc(100% - 40px))";
				document.getElementById("health-inner").style.width = (100 * healthPercent) + "%";
				document.getElementById("health-inner").style.backgroundColor = "rgb(" + healthR + ", " + healthG + ", " + healthB + ")";
	
				if (oxygen < 1) {
					document.getElementById("oxygen").style.display = "block";
					let oxygenPercent = oxygen;
					let oxygenR = clamp(2 - oxygenPercent * 2, 0, 1) * 255;
					let oxygenG = 0;
					let oxygenB = clamp(oxygenPercent * 2, 0, 1) * 255;
					document.getElementById("oxygen").style.width = 40 + "%";
					document.getElementById("oxygen-inner").style.width = 100 * oxygen + "%";
					document.getElementById("oxygen-inner").style.backgroundColor = "rgb(" + oxygenR + ", " + oxygenG + ", " + oxygenB + ")";
				} else {
					document.getElementById("oxygen").style.display = "none";
				};
				
				let minutes = (gameTime + 450) * ((12 * 60) / 300);
				let timeText = ((Math.floor(minutes / 60) % 12) || 12) + ":" + Math.floor(minutes % 60).toString().padStart(2, "0") + (Math.floor(((Math.floor(minutes / 60) % 24) / 12)) ? " AM" : " PM");
				document.getElementById("stats").innerHTML = "altitude: " + Math.floor(playerY) + "m<br>fps: " + fps + "<br>ü™ô " + bigIntString(coins) + "<br>üíé " + bigIntString(gems) + "<br><div class=\"emoji\" id=\"totem-emoji\"></div> " + bigIntString(totems) + "<br>ü•æ " + boots + "<br>" + clockEmoji(gameTime) + " " + timeText;
				document.getElementById("score").innerHTML = "‚óÑ " + bigIntString(score) + "m ‚ñ∫";
				document.getElementById("notification").innerHTML = notificationTime > 0 ? notification : "";
				for (let food in foods) {
					document.getElementById(food.replaceAll(" ", "-") + "-howmany").innerHTML = foods[food].howmany;
				};
				for (let potion in potions) {
					document.getElementById(potion.replaceAll(" ", "-") + "-howmany").innerHTML = potions[potion].howmany;
				};
				document.getElementById("ladder-howmany").innerHTML = ladders;
				document.getElementById("tall-ladder-howmany").innerHTML = tallLadders;
				document.getElementById("trampoline-howmany").innerHTML = trampolines;
				document.getElementById("seed-label-input").value = level.featureRNG.seed;
				document.getElementById("seed-label-input").style.width = level.featureRNG.seed.length + "ch";
			};
			var oldfpsTime = 0;
			function loop() {
				//try {
					tick();
					drawScreen();
				//} catch (e) {
				//	alert(e.stack);
				//	return;
				//};
				frameCount++;
				let now = performance.now();
				if (Math.floor(fpsUpdateTime / 1000) !== Math.floor(now / 1000)) {
					fpsUpdateTime = now;
					fps = frameCount;
					frameCount = 0;
				};
				//fps = Math.round(1 / ((performance.now() - oldfpsTime) / 1000));
				//oldfpsTime = performance.now();
				requestAnimationFrame(loop);
			};
			loop();
		</script>
		<script src="./textures.js"></script>
	</body>
</html>
